
\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Практика использования и \\наиболее полезные конструкции языка Rust}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Ресуры по языку Rust}

\url{https://www.rust-lang.org/tools}

\url{https://doc.rust-lang.org/book/}

\url{https://doc.rust-lang.org/stable/rust-by-example/}

\section{Установка Rust}

Установить Rust проще всего с помощью утилиты \texttt{rustup} -- это установщик языка и менеджер версий. Для операционной системы Windows можно скачать \texttt{rustup-init.exe} со страницы проекта \url{https://www.rust-lang.org/learn/get-started}

Установить Rust на Linux можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ curl https://sh.rustup.rs -sSf | bash
...
Current installation options:


default host triple: x86_64-unknown-linux-gnu
default toolchain: stable (default)
profile: default
modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
>1

info: profile set to 'default'
info: default host triple is x86_64-unknown-linux-gnu
info: syncing channel updates for 'stable-x86_64-unknown-linux-gnu'
...
\end{lstlisting}

Rust часто обновляется и чтобы получить последнюю версию, можно воспользоваться командной \texttt{rustup update}.

Собрать проект и обновить его зависимости можно с помощью утилиты \texttt{cargo}
\begin{lstlisting}[
style = bash,
numbers = none
]
cargo build  # build your project
cargo run  # cargo run
cargo test  # test project 
cargo doc  # build documentation for your project
cargo publish  # publish a libarary to crates.io
\end{lstlisting}

То есть \texttt{cargo} знает, как превратить Rust-код в исполняемый бинарный файл, а также может управлять процессом загрузки и компиляции проектных зависимостей.

\section{Вводные замечания}

\emph{Система владения} устанавливает \emph{время жизни} каждого значения, что делает ненужным сборку мусора в ядре языка и обеспечивает надежные, но вместе с тем гибкие интерфейсы для управления такими ресурсами, как сокеты и описатели файлов. Передеча (move) позволяет передавать значение от одного владельца другому, а заимствование (borrowing) -- использовать значение временно, не изменяя владельца.  

Rust -- типобезопасный язык. Но что понимается под типобезопасностью? Ниже приведено определение <<неопределенного поведения>> из стандарта языка С 1999 года, известного под названием <<C99>>: \emph{неопределнное поведение -- это поведение, являющееся следствием использования непереносимой или некорректной программной конструкции либо некорректных данных, для которого в настоящем Международном стандарте нет никаких требований}.

Рассмотрим следующую программу на С
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int main(int argc, char **argv) {
    // объявление одноэлементного массива беззнаковых длинных целых чисел
    unsigned long a[1];
    // обращение к 4-ому элементу массива; индекс, нарушает границу диапазона
    a[3] = 0x7ffff7b36cebUL; 
    return 0;
}
\end{lstlisting}

Эта программа обращается к элементу за концом массива \texttt{a}, поэтому согласно С99 ее \emph{поведение не определно}, т.е. она может делать все что угодно. {\color{red}<<Неопределенная>> операция не просто возвращает неопределнный результат, она дает программе карт-бланш на \emph{произвольное выполнение}(!).}

С99 предоставляет компилятору такое право, чтобы он мог генерировать более быстрый код. Чем возлагать на компилятор ответственность за обнаружение и обработку странного поведения вроде выхода за конец массива, стандарт предполагает, что программист должен позаботиться о том, чтобы такие ситуации никогда не возникали.

Если программа написана так, что ни на каком пути выполнения \emph{неопределенное выполнение невозможно}, то будем говорить, что программа \emph{корректна} (well defined).

Если встроенные в язык проверки \emph{гарантируют корректность программы}, то будем называть язык \emph{типобизопасным} (type safe).

Тщательно напсанная программа на C или C++ может оказаться типобезопасной, {\color{red}но ни C, ни C++ не является типобезопасным языком}: в приведенном выше примере нет ошибок типизации, и тем не менее она демонстрирует неопределенное поведение. С другой стороны, {\color{blue}Python -- \emph{типобезопасный} язык}, его интерпретатор тратит время на обнаружение выхода за границы массива и обрабатывает его лучше, чем компилятор С.

\section{Начало работы}

Создать проект на Rust можно командной \texttt{cargo new <project\_name>}
\begin{lstlisting}[
style = bash,
numbers = none	
]
$ cargo new hello  # создать проект hello
$ tree 
.
hello/
  Cargo.toml
  src/
    main.rs
$ cd hello
$ cargo run  # запустить проект
   Compiling hello v0.1.0 (/home/kosyachenko/Projects/GARBAGE/rust_projects/hello)
Finished dev [unoptimized + debuginfo] target(s) in 0.42s
Running `target/debug/hello`
Hello, world!
# Дерево проекта изменилось
$ tree
.
Cargo.lock  # артефакт
Cargo.toml
src/
  main.rs
target/  # артефакт
  CACHEDIR.TAG
  debug/
    build
    deps/
      hello-27...
      hello-27...d
    examples/
    hello
    hello.d
    incremental/
      hello-imy.../
        s-ghim...
\end{lstlisting}

В основном каталоге имеется файл \texttt{Cargo.toml}, содержащий описание метаданных проекта, таких как имя проекта, его версия и его зависимости. Исходный код попадает в директорию \texttt{src}.

Выполнение команды \texttt{cargo run} привело также к добавлению к проекту новых файлов. Теперь у нас в основном каталоге проекта есть файл \texttt{Cargo.lock} и каталог \texttt{target}. В \texttt{Cargo.lock} указываются конкретные номера версий всех зависимостей, чтобы будущие сборки составлялись точно также, как и эта, пока содержимое \texttt{Cargo.toml} не изменится.

\subsection{Первая программа на Rust}

Нужно как обычно с помощью \texttt{cargo new hello} создать новый проект. Перейти в созданную директорию проекта и в файле \texttt{main.rs} директории \texttt{src} написать следущее
\begin{lstlisting}[			
title = {\sffamily ./src/main.rs},
style = c_cpp,
numbers = none
]
fn greet_world() {
    println!("Hello, world!");
    let southern_germany = "Germany";
    let japan = "Japan";
    let regions = [southern_germany, japan];
    
    for region in regions.iter() {
        println!("{}", &region);
    }
}

fn main() {
    greet_world();
}
\end{lstlisting}

Восклицательный знак свидетельствует об использовании \emph{макроса}. Для операции присваивания в Rust, которую правильнее было бы называть \emph{привязкой переменной}, используется ключевое слово \texttt{let}. Поддержка Unicode предоставляется самим языком. 

Для \emph{литералов массива} используются \emph{квадратные скобки}. Для возврата итератора метод \texttt{iter()} может присутствовать во многих типах. Амперсанд <<заимствует>> \texttt{region} так, чтобы доступ предоставлялся \emph{только для чтения}.

Строки ганатировано получают кодировку UTF-8.

Пример
\begin{lstlisting}[
title = {\sffamily src/main.rs},
style = c_cpp,
numbers = none
]
fn main() {  // (1)
    let penguin_data = "\  // (2)
    common name,length (cm)
    Little penguin,33
    Yellow-eyed penguin,65
    Fiordland penguin,60
    Invalid,data
    ";
    
    let records = penguin_data.lines();
    
    for (i, record) in records.enumerate() {
        if i == 0 || record.trim().len() == 0 {  // (3)
            continue;
        }
    
        let fields: Vec<_> = record  // (4)
            .split(',')  // (5)
            .map(|filed| field.trim())  // (6)
            .collect();  // (7)
            if cfg!(debug_assertations) {  // (8)
                eprintln!("debug: {:?} -> {:?}", record, fields);  // (9)
            }
        
            let name = fields[0];
            if let Ok(length) = fields[1].parse::<f32>() {  // (10)
                println!("{}, {} cm", name, length);  // (11)
            }
    }
}
\end{lstlisting}

(1) -- исполняемым проектам требуется функия \texttt{main()}. (2) -- отключение завершающего символа новой строки. (3) -- пропуск строки заголовка и строк, состоящих из одних пробелов. (4) -- начало со строки текста. (5) -- разбиение записи на поля. (6) -- обрезка пробелов в каждом поле. (7) -- Сборка набора полей. (8) -- \texttt{cfg!} проверяет конфигурацию в процессе компиляции. (9) -- \texttt{eprintln!} выводит данные на страндартное устройство сообщений об ошибках (stderr). (10) -- попытка выполнения парсинга поля в виде числа с плавающей точкой. (11) -- \texttt{println!} помещает данные на страндартное устройство вывода (stdout).

Переменная \texttt{fields} помечена типом \verb|Vec<_>|. \verb|Vec| -- сокращение от \verb|_verctor_|, типа коллекции, способного динамически расширяться. Знак подчеркивания предписывает Rust вывести тип элемента.

На Python решение выглядело бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
#!python
import typing as t

def main():
    penguin_data: str = """
        common name, length (cm)
        Little penguin, 33
        Yellow-eyed penguin, 65
        Fiordland penguin, 60
        Invalid, data
    """
    
    records: t.List[str] = penguin_data.split("\n")
    
    for (i, record) in enumerate(records):
        if i == 0 or len(record.strip()) == 0:
            continue
            
        fields: t.List[str] = list(map(lambda field: field.strip()), records.split(","))
        # Или с помощью спискового включения
        # fields: t.List[str] = [record.strip() for record in records.split(",")]
        
        if __debug__:
            print(f"debug: {record} -> {fields}")
            
        name: str = fields[0]
        # На Rust это блок выглядит изящнее
        try:
            length = float(fields[1])
        except ValueError as err:
            continue
        else:
            print(f"{name}, {length} cm")
            

if __name__ == "__main__":
    main()
\end{lstlisting}

Макросы похожи на функции, но вместо возвращения данных они возвращают код. Макросы часто используются для упрощения общеупотребительных шаблонов. Поле заполнения \verb|{}| заставляет Rust воспользоваться методом представления значения в виде строки, который определил программист, а не представлением по умолчанию, доступным при указании поля заполнителя \verb|{:?}|.

\verb|if let Ok(length) = fields[1].parse::<f32>()| читается так <<попытаться разобрать \texttt{fields[1]} в виде 32-разрядного числа с плавающей точкой, и в случае успеха присвоить число переменной \verb|length|>>.

Конструкция \verb|if let| -- краткий метод обработки данных, предоставляющий также локальную переменную, которой присваиваются эти данные. Метод \verb|parse()| возвращает \texttt{Ok(T)} (где \verb|T| означает любой тип), если ему удается провести разбор строки; в противном случае он возвращает \texttt{Err(E)} (где \texttt{E} означает тип ошибки). Применение \verb|if let Ok(T)| позволяет пропустить любые случаи ошибок, подобные той, что встречаются при обработки строки \texttt{Invalid,data}.

Когда Rust не способен вывести тип из окружающего контекста, он запрашивает конкретное указание. В вызов \verb|parse()| включается встроенная аннотация типа в виде \verb|parse::<f32>()|.

Преобразование исходного кода в исполняемый файл называется \emph{компиляцией}.

В Rust-програмах отсуствуют:
\begin{enumerate}
	\item Висячие указатели -- прямые ссылки на данные, ставшие недействительными в ходе выполнения программы,
	
	\item Состояние гонки -- неспособность из-за изменения внешних факторов определить, как программа будет вести себя от запуска к запуску,
	
	\item Переполнение буфера -- попытка обращения к 12-му элементу массива, состоящего из 6 элементов
\end{enumerate}

В Rust \emph{пустой тип}: \texttt{()} (произносится как <<юнит>>). Когда нет никакого другоо значимого возвращаемого значения, выраженипе возвращает \texttt{()}.

Rust предлагает программистам детальный контроль над размещением структур данных в памяти и над схемами доступа к ним. Временами возникает острая потребность в управлении производительностью приложения. При этом важную роль может сыграть хранение данных в \emph{стеке}, а не в \emph{куче}. 
  
Особые возможности Rust:
\begin{itemize}
	\item Достижение высокой производительности,
	
	\item Выполнение одновременных (параллельных) вычислений,
	
	\item Достижение эффективной работы с памятью.
\end{itemize}

Rust позволяет воспользоваться всей доступной производительностью комьютера. Он не использует для обеспечения безопасности памяти сборщик мусора.

В Rust нет никакой глобальной блокировки интерпретатора, ограничивающей скорость потока.

Единицей компиляции программы на Rust является не отдельный файл, а целый пакет (известный как \emph{крейт}). Поскольку крейты могут включать в себя несколько модулей, они могут становится весьма большими объектами компиляции. Это конечно, позволяет оптимизировать весь крейт, но требует также его компиляции.

\texttt{let} используется для \emph{привязки переменной}. По умолчанию переменные \emph{неизменяемы}, то есть предназначены только для чтения, а не для чтения-записи.

\section{Основы языка}

\subsection{Числа}

Преобразования между типами всегда носят явный характер. В Rust у чисел могут быть методы: например, для округления \texttt{24.5} к ближайшему целому числу используется \verb|24.5_f32.round()|, а не \verb|round(24.5)|.

Литералы чисел с плавающей точкой без явно указанной аннотации типа становятся 32- или 64-разрядными в зависимости от контекста.

Имеющиеся в Rust требования к безопасности типов \emph{не позволяют проводить сравнение между типами}. Например, следующий код не пройдет компиляцию:
\begin{lstlisting}[
style = c_cpp,
numbers = none,
]
fn main() {
    let a: i32 = 10;
    let b: u16 = 100;
    
    if a < b {  // error[E0308]: mismatched types
        println!("Ten is less then one hundred.")
    }
}
\end{lstlisting} 

Безопаснее всего привести меньший тип к большему (например, 16-разрядный тип к 32-разрядному): \verb|(b as i32)|. Иногда это называют расширением.

Порой использовать ключевое слово \texttt{as} накладывает слишком большие ограничения. В следущем листинге показан Rust-метод, заменяющий ключевое слово \texttt{as} в тех случаях, когда приведение может дать сбой
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use std::convert::TryInto;

fn main() {
    let a: i32 = 10;
    let b: u16 = 100;
    
    let b_ = b.try_into().unwrap();  // try_into() -> тип Result
    
    if a < b_ {
        println!("Ten is less than one hundred.");
    }
}
\end{lstlisting}

Ключевое слово \texttt{use} переносит типаж \verb|std::convert::TryInto| в локальную область видимости. В результате этого происходит разблокирование метода \verb|try_into()|, вызываемого в отношении переменной \texttt{b}. 

\emph{Типажи} можно рассматривать как \emph{абстрактные классы} или \emph{интерфейсы}. Метод \verb|b.try_into()| возвращает значение типа \verb|i32|, завернутое в значение типа \texttt{Result}. Значение успеха может быть обработано методом \verb|unwrap()|, в результате чего здесь будет возвращено значение \texttt{b}, имеющее тип \verb|i32|.

Rust включает ряд допуско, позволяющих сравнивать числовые значения с плавающей точкой. Эти допуски определяются как \verb|f32::EPSILON| и \verb|f64::EPSILON|.

Операции, выдающие математически неопределенные результаты, например извлечение квадратного корня из отрицательного числа, создают особые проблемы. Для обработки таких случаев в тип числа с плавающей точкой включены знаения NaN -- <<not a number>>.

Чтобы добавить контейнер (крейт) в проект достаточно добавить в раздел \texttt{[dependencies]}имя крейта и его версию в файл \texttt{Cargo.toml}
\begin{lstlisting}[
title = {\sffamily Cargo.toml},
style = bash,
numbers = none
]
...
[dependencies]
num = "0.4"
...
\end{lstlisting}

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use num::complex::Complex;

fn main() {
    let a = Complex {re: 2.1, im: -1.2};  // у каждого типа в Rust имеется литеральный синтаксис
    let b = Complex::new(11.1, 22.2);
    let result = a + b;
    
    println!("{} + {}i", result.re, result.im);  // доступ к полям через оператор точка
}
\end{lstlisting}

Ключевое слово \texttt{use} помещает тип \texttt{Complex} в локальную область видимости. В Rust нет конструкторов, вместо этого у каждого типа есть литеральная форма.

Инициализировать типы можно путем использования имени типа и присвоения его полям значений в фигурных скобках: \verb|Complex { re: 2.1, im: -1.2 }|. Для упрощения программ метод \verb|new()| реализован у многих типов. Но это соглашение не часть языка Rust.

Поддерживаются две форму инициализации неэлементарных типов:
\begin{itemize}
	\item Литеральный синтаксис: \verb|Complex { re: 2.1, im: -1.2 }|,
	
	\item Статическим методом \verb|new()|: \verb|Complex::new(11.1, 22.2)|.
\end{itemize}

Статический метод -- это функция, доступная для \emph{типа}, но не для \emph{экземпляра типа}. В реальном коде предпочтительнее вторая форма.

\subsection{Управление ходом выполнения программы}

Базовая форма цикла \texttt{for} имеет следующий вид
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for item in container {
    // ...
}
\end{lstlisting}

Эта базовая форма делает каждый последующий элемент в контейнере \texttt{container} доступным в качестве элемента \texttt{item}.

Несмотря, на то, что переменная \texttt{container} остается в локальной области видимости, теперь ее \emph{время жизни} истекло. Rust считает, что раз блок закончился, то надобности в переменной \texttt{container} миновала.

Когда чуть позже в программе возникнет желание воспользоваться переменной \texttt{container} еще раз, следует воспользоваться указателем. Когда указатель опущен, Rust полагает, что переменная \texttt{container} больше не нужна. Чтобы добавить \emph{указатель} на контейнер, нужно, как показано в следующем примере, поставить перед его именем знак амперсанда (\verb|&|)
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for item in &container {
    // ...
}
\end{lstlisting}

Если в ходе циклического перебора элементов нужно внести изменения в каждый элемент, можно воспользоваться \emph{указателем}, \emph{допускающим изменения}, включив в код ключевое слово \texttt{mut}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for item in &mut container {
    // ...
}
\end{lstlisting}

\emph{Безымянные циклы}. Если в блоке не используется локальная переменная, то по соглашению применяется знак подчеркивания <<\verb|_|>>. Использование этой схемы в сочетании с синтаксисом \emph{исключающего диапазона} (\verb|n..m|) и синтаксисом \emph{включающего диапазона} (\verb|n..=m|) показывает, что целью является выполнение цикла фиксированное количество раз. Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for _ in 0..10 {
    // ...
}
\end{lstlisting}

Ключевое слово \texttt{continue} действует вполне ожидаемым образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// Вывести только нечетные 
for item in 0..10 {
    if item % 2 == 0 {
        continue;
    }
}
\end{lstlisting}

Прерывание цикла выполняется с помощью ключевого слова \texttt{break}. При этом Rust работает превычным образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn main() {
    for (x, y) in (0..).zip(0..) { // zip работает на бесконечной последовательности
        if x + y > 100 {
            break;
        }
        println!("x={}, y={}", x, y);
    }
}
\end{lstlisting}

В Python пришлось бы организовывать бесконечный цикл \texttt{while}, например так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def main():
    x, y = (0, 0)
    while True:
        if x + y > 100:
            break
        print(f"x={x}, y={y}")
        x += 1
        y += 1
\end{lstlisting}

Прерывание во вложенных циклах. Прервать выполнение вложенного цикла можно с помощью \emph{меток циклов}. Метка цикла представляет собой идентификатор с префиксом в виде \emph{апострофа} \verb|'|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
`outer: for x in 0.. {
    for y in 0.. {
        for z in 0.. {
            if x + y + z > 10 {
                break `outer;
            }
            // ...
        }
    }
}
\end{lstlisting}

Условное ветвление. \texttt{if} допускает применение любого выражения, вычисленного в булево значение (\texttt{true} или \texttt{false}). Когда нужно протестировать несколько значений, можно добавить цепочку блоков \texttt{if else}. Блок \texttt{else} соответствует всему, чему еще не нашлось соответствие. Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
if item == 42 {
    // ...
} else if item == 132 {
    // ...
} else {
    // ...
}
\end{lstlisting}

В Rust отсутствует концепция <<правдивых>> или <<ложных>> типов. В других языках (например, в Python) допускается, чтобы особые значения, например 0 или пустая строка, означали \texttt{false}, а другие значения означали \texttt{true}, но в Rust это не практикуется. Единственным значением, которое может быть \texttt{true}, является \texttt{true}, а за \texttt{false} может принимать только \texttt{false}.

Rust -- язык, основанный на выражениях. Для Rust характерно обходится без ключевого слова \texttt{return}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn is_even(n: i32) -> bool {
    n % 2 == 0
}

fn main() {
    let n: i32 = 123456;
    let description = if is_even(n) {
        "even"
    } else {
        "odd"
    };

    prinln!("n={} is {}", n, description);
}
\end{lstlisting}

Этот прием может распространяться и на другие блоки, включая \texttt{match}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn is_even(n: i32) -> bool {
    n % 2 == 0
}

fn main() {
    lst n = 654321;
    let description = match is_even(n) {
        true => "even",
        false => "odd",
    };

    println!("n={} is {}", n, description);
}
\end{lstlisting}

\subsection{Расширенные определения функций}

Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
fn add_with_lifetimes<'a, 'b>(i: &'a i32, j: &'b i32) -> i32 {
    *i + *j
}
\end{lstlisting}
\begin{itemize}
	\item \verb|fn add_with_lifetimes(...) -> i32| -- функция, возвращающая значение типа \verb|i32|,
	
	\item \verb|<'a, 'b>| -- объявление двух \emph{переменных времени жизни}, \verb|'a| и \verb|'b|, в области видимости функции \verb|add_with_lifetimes()|. Обычно о них говорят как о \emph{времени жизни} \emph{a} и \emph{времени жизни}~\emph{b},
	
	\item \verb|i: &'a i32| -- привязка {\color{blue}\emph{переменной времени жизни} \verb|'a|} к времени жизни \texttt{i}. Этот синтаксис читается так <<параметр \texttt{i} является \emph{указателем} на \verb|i32| с {\color{blue}временем жизни \emph{a}}>>,
	
	\item \verb|j: &'b i32| -- привязка {\color{blue}\emph{переменной времени жизни} \verb|'b|} к времени жизни \texttt{j}. Этот синтаксис читается так <<параметр \texttt{j} является \emph{указателем} на \verb|i32| с {\color{blue}времнем жизни \emph{b}}>>.
\end{itemize}

Основа проводимых в Rust проверок безопасности -- система времени жизни, позволяющая убедиться, что все попытки обращения к данным являются допустимыми. Все значения, привязанные к данному времени жизни, должны существовать вплоть до последнего доступа к любому значению, привязанному к этому же времени жизни.

Обычно система времени жизни работает без посторонней помощи. Хотя время жизни есть почти у каждого параметра, проверки в основном проходят скрытно, поскольку компилятор может определить время жизни самостоятельно. Но в сложных случаях компилятору нужна помощь.

При вызове функции аннотации времени жизни не требуются. 
\begin{lstlisting}[
style = bash,
numbers = none
]
fn add_with_lifetimes<'a, 'b>(i: &'a i32, j: &'b i32) -> i32 {
    *i + *j  // (1)
}

fn main() {
    let a = 10;
    let b = 20;
    let res = add_with_lifetimes(&a, &b);  // (2)
    println!("{}", res);
}
\end{lstlisting}

(1) -- сложение значений, на которые указывают \texttt{i} и \texttt{j}, а не сложение непосредственно самих указателей. (2) -- \verb|&a| и \verb|&b| означают \emph{указатели} соответственно на 10 и 20.

Использование двух параметров времени жизни (\texttt{a} и \texttt{b}) показывает, что времени жизни \texttt{i} и \texttt{j} не связаны друг с другом.

\subsubsection{Обобщенные функции}

Типовая сигнатура обобщенной функции
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn add<T>(i: T, j: T) -> T {
    i + j
}
\end{lstlisting}

\emph{Переменная типа} \texttt{T} вводится в угловых скобках (\verb|<T>|). Эта функция принимает два аргумента одного и того же типа и возврщает значение такого же типа.

Заглавные буквы вместо типа указывают на \emph{обобщенный тип}. В соответствие с действующим соглашением в качестве заместителей используются произвольно выбираемые переменные \texttt{T}, \texttt{U} и \texttt{V}. А переменная \texttt{E} часто применяется для обозначения типа ошибки.

Обобщения позволяют использовать код многократно и могут существенно повысить удобство работы со строго типизированными языками.

Все Rust-операторы, включая сложение, определены в \emph{типажах}. Чтобы выставить требование, что тип \texttt{T} должен поддерживать сложение, в определение функции наряду с переменной типа включается \emph{типажное ограничение}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// std::ops::Add -- типаж
fn add<T: std::ops::Add<Output = T>>(i: T, j: T) -> T {
    i + j
}
\end{lstlisting}

Фрагмент \verb|<T: std::ops::Add<Output = T>>| предписывает, что в \texttt{T} должна быть реализация операции \verb|std::ops::Add|. Использование одной и той же переменной типа \texttt{T} с типажными ограничением гарантирует, что агрументы \texttt{i} и \texttt{j}, а также возвращемое значение будут одного и того же типа и их типы поддеживают сложение.

\emph{Типаж} -- это что-то вроде \emph{абстактного базового класса}. Все Rust-операции определяются с помощью типажей. Например, оператор сложения (+) определен как типаж \verb|std::ops::Add|.

Все Rust-операторы являются удобным синтаксическим примемом для вызова \emph{методов типажей}. В ходе компиляции выполняется преобразование выражения \verb*|a + b| в \verb|a.add(b)|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use std::ops::{Add};
use std::time::{Duration};

fn add<T: Add<Output = T>>(i: T, j: T) -> {
    j + j
}

fn main() {
    let floats = add(1.2, 3.2);
    let ints = add(10, 20);
    let duratoins = add(
        Duration::new(5, 0),
        Duration::new(10, 0)
    );
    
    println!("{}", floats);
    println!("{}", ints);
    println!("{:?}", durations);
}
\end{lstlisting}

\subsection{Создание списков с использованием массивов, слайсов и векторов}

\subsubsection{Массивы}

\emph{Массивы} характеризуются фиксированной шириной и чрезвычайной скромностью в потреблении ресурсов. \emph{Векторы} можно наращивать, но им свойственны издержки времени выполнения из-зи ведения дополнительного учета. 

В \emph{массиве} допускается замена элементов, но его \emph{\color{red}размер менять нельзя}.

Описание типа массива имеет следующий вид: \verb|[T; n]|, где \texttt{T} -- тип элемента, а \texttt{n} -- неотрицательное целое число. Например, запись \verb|[f32; 12]| обозначает массив из двенадцати 32-разрядных чисел с плавающей точкой. 

Особое внимание в Rust уделяется вопросам безопасности. При этом ведется проверка границ индексации массива. Запрос элемента, выходящего за границы, приводит к сбою (к панике в терминологии Rust), а не к возврату неверных данных.

\subsubsection{Слайсы}

Слайсы представляют собой похожие на массив объекты с динамическим размером. Понятие <<динамический размер>> означает, что их размер на момент компиляции \emph{неизвестен}. Но, как и массивы, они не могут расширяться или сокращаться.

Недостаток сведений к моменту компиляции объясняет различие в сигнатуре типа между массивом (\verb|[T;n]|) и слайсом (\verb|[T]|).

Важность слайсов объясняется тем, что реализовать типаже дли них проще, чем для массивов. Поскольку \verb|[T; 1]|, \verb|[T; 2]|, ..., \verb|[T; n]| бывают разных типов, реализация типажей для массивов может стать слишком громоздской. А создание \emph{слайса} из массива дается легко и обходится дешево, поскольку \emph{слайс не нужно привязывать к какому-либо конкретному размеру}.

Слайсы способны действовать как \emph{представление массивов} (и других слайсов). Термин <<представление>> здесь взят из описания технологии работы с базами данных и означает, что слайсы могут получать быстрый доступ только по чтению данных, что исключает необходимость копирования чего бы то ни было.

\subsubsection{Векторы}

Векторы (\verb|Vec<T>|) -- это наращиваемые списки, состоящие из обобщенных типов \texttt{T}. При выполнении программы на них тратится немного больше времени, чем на массивы, из-за дополнительного учета, необходимого для последующего изменения их размера. Но эти издержки на работу с векторами почти всегда компенсируются их дополнительной гибкостью. 

\verb|Vec<T>| эффективнее всего работает при возможности указания размера с помощью функции \verb|Vec::with_capacity()|. Предоставление этого показателя сводит к минимуму необходимое количество выделенной памяти операционной системой.

\subsection{Чтение данных из файлов}

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use std::fs::File;
use std::io::BufReader;
use std::io::prelude;

fn main() {
    let f = File::open("readme.md").unwrap();
    let reader = BufReader::new(f);
    
    for line_ in reader.lines() {
        let line = line_.unwrap();
        println!("{} ({} bytes long)", line, line.len());
    }
}
\end{lstlisting}

На Python было бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def main():
    with open("readme.md", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            print(f"{line} ({len(line)} bytes long)")
\end{lstlisting}

\section{Составные типы данных}

Чтобы помешать компилятору выдавать предупреждения, в них будут задействованы атрибуты \verb|#![Allow(unused_variables)]|.

Тип, известный как \emph{unit} \verb|()|, формально считается \emph{кортежем нулевой длины}. Он используется для выражения того, что \emph{функция не возвращает никакого значения}.

Функции, которые не имеют возвращаемого типа, возвращают \verb|()|, и выражения, заканчивающиеся точкой с запятой \verb|;|, также возвращают \verb|()|. Например, функция \texttt{report()} в следующем блоке кода подразумеваемо возвращает тип \emph{unit}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use std::fmt::Debug;

fn report<T: Debug>(item: T) { // item может быть любого типа с реализацией std::fmt::Debug
    println!("{:?}", item);
}
\end{lstlisting}

А в этом примере возвращение типа unit задается в явном виде
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn clear(text: &mut String) -> () {
    *text = String::from(""); // замена строкового значения, на которое указывает text, пустой строкой
}
\end{lstlisting}

В Python затереть значение переменной в глобальной области видимости можно было бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
>>> text = "global"
>>> def clear():
      global text  # просто расширяем область видимости функции
      text = ""  # привязываем переменную text к пустой строке
>>> text  # 'global'
>>> clear()
>>> text  # '' 
\end{lstlisting}

Последнее выражение в функции не должно заканчиваться точкой с запятой. \emph{Восклицательный знак} \verb|!|, известен как тип <<Never>>. \verb|Never| показывает, что \emph{функция никогда ничего не возвращает}, особенно при гарантированном сбое.

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn dead_end() -> ! { // функция никогда ничего не возвращает
    panic!("you have reached a dead end");
}
\end{lstlisting}

Макрос \verb|panic!| вызывает сбой программы. То есть функция \emph{гарантировано никогда не вернет управление} вызвавшему ее коду.

Структура \texttt{struct} позволяет создавать составной тип, образованный из других типов. Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct File {
    name: String,
    data: Vec<u8>,
}
\end{lstlisting}

Чтобы позволить структуре \texttt{File} стать выводимой на экран строкой, нужно поместить строку \verb|#[derive(Debug)]| перед определением структуры

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#[derive(Debug)]  // чтобы можно было вывести на печать структуру
struct File {
	name: String,
	data: Vec<u8>,
}
\end{lstlisting}

При определении структуры можно явно указывать время жизни каждого поля. Явное указание времени жизни требуется, когда поле является ссылкой на другой объект.

Экземпляр структуры можно создать так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn main() {
    let f1 = File { // экземпляр структуры
        name: String::from("f1.txt"),
        data: Vec::new(),
    };

    let f1_name = &f1.name;
    let f1_length = &f1.data.len();
    
    println!("{:?}", f1);
}
\end{lstlisting}

К началу имени добавляется амперсанд (\verb|&f1.name|), свидетельствующий о желании получить \emph{доступ к данным по ссылке}. На языке Rust это означает, что переменные \verb|f1_name| и \verb|f1_length| \emph{заимствуют} данные, на которые они ссылаются.

\subsection{Добавление метдов к структуре struct путем использования блока impl}

В Rust классы, так сказать, распадаются на структуры \texttt{struct} и реализации \texttt{impl}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct File {
    // data
}

impl File {
    // methods
}
\end{lstlisting}

Rust отличается от других языков, поддерживающих методы: в нем нет ключевого слова \texttt{class}. Типы, созданные с помощью блока \texttt{struct}, иногда кажутся классами, но поскольку они \emph{не поддерживают наследование}, то хорошо, что их называли по-другому.

Для определения методов Rust-программистами используется блок \texttt{impl}.

Создание объектов с уместными значениями по умолчанию выполняется с помощью метода \texttt{new()}. Каждую структуру можно создать, воспользовавшись литеральным синтаксисом, но это приводит к ненужной многословности.

Использование \texttt{new()} -- соглашение, принятое в сообществе Rust. В отличие от других языков, \texttt{new} не является ключевым словом и не имеет какого-либо особого статуса по сравнению с другими методами
\begin{lstlisting}[
title = {Использование блока impl для добавления методов к структуре},
style = c_cpp,
numbers = none
]
#[derive(Debug)]
struct File {
    name: String,
    data: Vec<u8>,
}

impl File {
    fn new(name: &str) -> File {
        File {
            name: String::from(name),
            data: Vec::new(),
        }
    }
}

fn main() {
    let f3 = File::new("f3.txt");
    
    let f3_name = &f3.name;
    let f3_length = f3.data.len();
    
    println!("{:?}", f3);
    println!("{} is {} bytes long", f3_name, f3_length);
}
\end{lstlisting}

В Rust небезопасность означает <<тот же уровень безопасности, который всегда обеспечивается языком С>>.

Небольшие дополнения к языку Rust:
\begin{itemize}
	\item Изменяемые глобальные переменные обозначаются с помощью \verb|static mut|,
	
	\item По соглашению в именах глобальных переменных ВСЕ БУКВЫ ЗАГЛАВНЫЕ,
	
	\item Ключевое слово \texttt{const} включается для тех значений, которые никогда не изменяются.
\end{itemize}

Опытным программистам известно, что использование глобальной переменной \texttt{errno} во время системных вызовов обычно регулируется операционной системой. Как правило, в Rust такой стиль программирования не приветствуется, поскольку при нем не только нарушается безопасность типов (ошибки кодируются в виде простых целых чисел), но и в <<награду>> неравдивым программистам, забывающим проверить значение переменной \texttt{errno}, может проявиться нестабильность программ.

\paragraph{Разница между \texttt{const} и \texttt{let}} Данные, определяемые с \texttt{let}, могут изменяться. Rust позволяет типам обладать явно противоречивым свойством \emph{внутренней изменчивости}.

Некоторые типы, например \verb|std::sync::Arc| и \verb|std::rc::Rc|, представляют собой неизменяемый фасад, но по прошествии времени изменяют свое внутренее состояние. По мере того, как на них делаются ссылки, они увеличивают значение счетчика ссылок и уменьшают его значение, когда срок действия этих ссылок истекает.

На уровне компилятора \texttt{let} больше относится к использованию псевдонимов, чем к неизменяемости. Использование псевдонимов в понятиях компилятора означает одновременное наличие нескольких ссылок на одно и то же место в памяти.

Ссылки на переменные, доступные только для чтения (их заимствования), объявленные с помощью \texttt{let}, могут указывать на одни и те же данные. Ссылки для чтения-записи (изменяемые заимствования) гарантированно никогда не станут псевдонимами данных.

\subsection{Использование возвращаемого типа Result}

Подход, принятый в Rust к обработке ошибок, заключается в использовании типа, который соответствует как стандартному случаю, так и случаю ошбики. Этот тип известен как \texttt{Result}. У него два состояния: \texttt{Ok} и \texttt{Err}.

Для вызова функций, возвращающих \texttt{Result<File, String>}, требуется дополнительный метод \verb|unwrap()|, позволяющий извлечь значение. Вызов \verb|unwrap()| снимает оболочку с \verb|Ok(File)| для создания \verb|File|. При обнаружении ошибки \verb|Err(String)| прогрмма даст сбой.

\texttt{Result} -- перечисление \texttt{enum}. Перечисление \texttt{enum} -- это тип, способный представлять несколько известных вариантов, например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum Suit {
    Clubs,
    Spades,
    Diamonds,
    Hearts,
}

enum Card {
    King(Suit),
    Queen(Suit),
    Jack(Suit),
    Ace(Suit),
    Pip(Suit, usize),
}
\end{lstlisting}

Как и структуры, \emph{перечисления} поддерживают \emph{методы} через блоки \texttt{impl}. Перечисления в Rust эффективнее набора констант.

Определение основных характеристик типажа Read для File
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#![allow(unused_variables)]

// структура 
#[derive(Debug)]
struct File;

// типаж для структуры File, задающий протокол
trait Read {
	fn read( // этот метод должен быть реализован в блоке impl
		self: &Self, // пседотип
		save_to: &Vec<u8>,
	) -> Result<usize, String>;
}

// имплементация
impl Read for File {
	fn read(
		self: &File,
		save_to: &Vec<u8>,
	) -> Result<usize, String> {
		Ok(0)
	}
}

fn main() {
	let f = File{};
	let mut buffer = vec![];
	let n_bytes = f.read(&mut buffer).unwrap();
	
	println!("{} byte(s) read from {:?}", n_bytes, f);
}
\end{lstlisting}

\texttt{Display} требует, чтобы в типах был реализован метод \texttt{fmt}, возвращающий \texttt{fmt::Result}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// типаж (протокол/контракт/интерфейс) Display требует,
// чтобы в типе был реализован метод fmt
impl Display for FileState {
    fn fmt(
        &self,
        f: &mut fmt::Formatter,
    ) -> fmt::Result {
        match *self {
            FileState::Open => write!(f, "OPEN"),
            FileState::Closed => write!(f, "CLOSED"),
        }
    }
}

// типаж (протокол/контракт/интерфейс) Display требует,
// чтобы в типе был реализован метод fmt
impl Display for File {
    fn fmt(
        &self,
        f: &mut fmt::Formatter,
    ) -> fmt::Result {
        write!(f, "<{} ({})>", self.name, self.state)
    }
}
\end{lstlisting}

Rust'ие перечисления напоминают Python'ие именованные кортежи
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# Rust
# enum FileState {
#    Open,
#    Closed
# }
from collection import namedtuple

attrs = ("open", "closed")
FileState = namedtuple("FileState", attrs)(*attrs)
FileState.open # 'open'
FileState.closed # 'closed'
\end{lstlisting}

Для сборки документации проекта без зависимостей
\begin{lstlisting}[
style = bash,
numbers = none
]
$ cargo doc --no-deps --open
\end{lstlisting}

Группа символов \verb|///| приводит к созданию документов, ссылающихся на элемент, который следует непосредственно за ней
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
/// Represents a "file",
/// which probaly lives on a file system.
#[derive(Debug)]
pub struct File {
    name: String,
    data: Vec<u8>,
}

impl File {
    /// New files are assumed to be empty, but a name is required.
    pub fn new(name: &str) -> File {
         File {
             name: String::from(name),
             data: Vec::new(),
         }
    }
}
\end{lstlisting}

Можно приемы форматирования текста на Markdown
\begin{lstlisting}[
numbers = none
]
...
impl File {
    /// Creates a new, empty `File`.
    ///
    /// #*Examples*
    /// ```
    /// let f = File::new("f1.txt");
    /// ```
    pub fn new(name: &str) -> File {
        File {
            name: String::from(name),
            data: Vec::new(),
        }
    }
}
\end{lstlisting}

Строки, начинающиеся с \verb|///| попадут в документацию. То есть это что-то вроде Python'их doc-strings.

С группы символов \verb|//!| начинается описание проекта.

\section{Время жизни, владение и заимствование}

\emph{Контроллер заимствований} (borrow checker) -- проверяет \emph{законность} любого \emph{доступа к данным}, что позволяет Rust избежать проблем с безопасностью.

Проверка заимствований основана на трех взаимосвязанных понятиях:
\begin{enumerate}
	\item Время жизни,
	
	\item Владение,
	
	\item Заимствование.
\end{enumerate}

\emph{Владение} в Rust связано \emph{с избавлением от значений}, в которых больше нет надобности. Например, функция возвращает управление, необходимо освободить память, содержащую ее локальные переменные.

\emph{Время жизни значения} -- это период, в течение которого доступ к этому значению -- допустимое поведение. Локальные переменные функции живут до тех пор, пока функция не вернет управление, а глобальные переменные могут жить в течение всего времени жизни программы.

\emph{Позаимствовать} значение означает \emph{получить к нему доступ}. Суть этого термина призвана подчеркнуть возможность общего доступа к значениям из многих частей программы при наличии у них одного владельца.

Термин \emph{перемещение} (move) в Rust  означает нечто специфическое. Движение внутри кода Rust относится к \emph{переходу владения}, а не к перемещению данных. 

\emph{Владение} -- это понятие, используемое в сообществе Rust для обозначения процесса времени компиляции, который проверяет, что каждое использование значения допустимо и что каждое значение полностью уничтожено. Каждое значение внутри Rust -- это владение.

Попытка перезаписи значения, которое все еще доступно в другом месте программы, приводит к тому, что компилятор отказывается компилировать программу.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn main() {
	// Владение возникает здесь при создании объекта CubeSat
    let sat_a = CubeSat { id: 0 };
    // ...
    // Владение объектом переходит к check_status(), но не возвращается к main()
    let a_status = check_status(sat_a);
    // ...
    // sat_a больше не владелец объекта, что делает доступ недействительным
    let a_status = check_status(sat_a);
}
\end{lstlisting}

В ходе вызова \verb|check_status(sat_a)| владение переходит к функции \verb|check_status()|. Когда \verb|check_status()| возвращает сообщение, она удаляет значение \verb|sat_a|. Здесь время жизни \verb|sat_a| заканчивается. И все же после первого вызова \verb|check_status()| переменная \verb|sat_a| остается в локальной области видимости функции \verb|main()|. Попытка получения доступа к этой переменной вызовет возмущение контролера зависимостей.

В Rust у \emph{элементарных типов} особое поведение. В них реализован типаж \verb|Copy|. {\color{blue}Формально \emph{элементарные типы} обладают \emph{семантикой копирования}, а все другие типы имеют \emph{семантику перемещения}.}

{\color{red}При использовании значений в качестве аргумента той функции, которая становится их владельцем, получить к этим значениям новый доступ из внешней области видимости уже невозможно.}

\begin{lstlisting}[
title = {\sffamily \emph{Семантика копирования} элементарных типов Rust},
style = c_cpp,
numbers = none
]
fn use_value(_val: i32) {}

fn main() {
    let a = 123;
    use_value(a);
    
    println!("{}", a);  // + получение доступа к `a` после вызова use_value() вполне нормально
}
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily \emph{Семантика перемещения} для типов, не реализующих Copy},
style = c_cpp,
numbers = none
]
fn use_value(_val: Demo) {}

struct Demo {
    a: i32,
}

fn main() {
    let demo = Demo {a: 123};
    use_value(demo);
    
    println!("{}", demo.a);  // - доступ к demo.a невозможен даже после возвращения из use_value()
}
\end{lstlisting}

В Rust \emph{передача владения} от одной переменной к другой осуществляется двумя способами:
\begin{enumerate}
	\item по привязке переменной
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn main() {
    let sat_a = CubeSat { id: 0 }; // передача владения по привязке переменной
}
\end{lstlisting}
	
	\item через функциональный барьер либо в качестве аргумента, либо в качестве возвращаемого значения
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
fn main() {
    let sat_a = CubeSat { id: 0 };
    // ...
    let new_sat_a = check_status(sat_a); // передача владения через функциональный барьер
    // ...
}
\end{lstlisting}
\end{enumerate}

\subsection{Решение проблем, связанных с владением}

Изюминка Rust -- система владения. Ею обеспечивается безопасность памяти без использования сборщика мусора.

\subsubsection{Если полное владение не требуется, используйте ссылки}

Чаще всего в код вносится уменьшение необходимого уровня доступа. Вместо запроса владения в определениях функций можно воспользоваться <<заимствованием>>.

Для доступа \emph{только по чтению} следует использовать \verb|&T|, а для доступа \emph{по чтению-записи} -- \verb|&mut T|.

\begin{lstlisting}[
title = {\sffamily Использование владения},
style = c_cpp,
numbers = none
]
fn send(to: CubeSat, msg: Message) {
    to.mailbox.messages.push(msg); // владение значением переменной to переходит функции send
}
\end{lstlisting}

Владение значением переменной \texttt{to} переходит к функции \texttt{send()}. При возвращении из \texttt{send()} значение переменной \texttt{to} \emph{удаляется}.

\begin{lstlisting}[
title = {\sffamily Использование \emph{ссылки} на изменяемое значение},
style = c_cpp,
numbers = none
]
fn send(to: &mut CubeSat, msg: Message) {
    to.mailbox.messages.push(msg);
}
\end{lstlisting}

Добавление префикса \verb|&mut| к типу \texttt{CubeSat} позволяет \emph{внешней области видимости сохранять владение данными}, на которые \emph{указывает} переменная \texttt{to}.

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
impl GrounStation {
    fn send(
        &self,
        to: &mut CubeSat,
        msg: Message,
    ) {
        to.mailbox.messages.push(msg);
    }
}

impl CubeSat {
    fn recv(&mut self) -> Option<Message> {
        self.mailbox.messages.pop()
    }
}
\end{lstlisting}

Здесь \verb|&self| указывает, что \verb|GroundStation.send()| требуется ссылка на \verb|self| \emph{с доступом только на чтение}. Получатель берет \emph{изменяемое заимствование} (\verb|&mut|) экземпляра \verb|CubeSat|, а \verb|msg| становится полноправным владельцем его экземпляра \verb|Message|.

Владение экземпялром сообщения \verb|Message| переходит от \verb|msg| к локальной переменной функции \verb|message.push()|.

\subsubsection{Сократите количество долгоживующих значений}

Если есть крупный долгоживующий объект, например глобальная переменная, то хранить его для каждого компонента программы, который в нем нуждается, весьма неудобно.

Вместо использования долгоживующих объектов стоит подумать о создании недолговечных отдельных объектов. Иногда проблемы, связанные с владением, можно решить за счет пересмотра конструкций всей программы.

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
impl GroundStation {
    fn send(
        &self,
        mailbox: &mut Mailbox,
        to: &CubeSat,
        msg: Message,
    ) {
        mailbox.post(to, msg);
    }
}

impl CubeSat {
    fn recv(
        &self,
        mailbox: &mut Mailbox,
    ) -> Option<Message> {
        mailbox.deliver(&self)
    }
}

impl Mailbox {
    fn post(
        &mut self,  // изменяемый доступ к самому себе
        msg: Message  // владение сообщением
    ) {
        self.message.push(msg);
    }

    fn deliver(
        &mut self,
        recipient: &CubeSat
    ) -> Option<Message> {
        for i in 0..self.message.len() {
            if self.messages[i].to == recipient.id {
                let msg = self.messages.remove(i);
                return Some(msg);
            }
        }
        None
    }
}
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily Реализации стратегии недолговечных переменных},
style = c_cpp,
numbers = none
]
#![allow(unused_variables)]

#[derive(Debug)]
struct CubeSat {
    id: u64
}

#[derive(Debug)]
struct Mailbox {
    messages: Vec<Message>,
}

#[derive(Debug)]
struct Message {
    to: u64,
    content: String,
}

struct GroundStation {}

impl Mailbox {
    fn post(
        &mut self,  // метод будет изменять экземпляр Mailbox
        msg: Message
    ) {
        self.messages.push(msg);
    }

    fn deliver(
        &mut self,  // метод будет изменят экземпляр Mailbox
        recipient: &CubeSat
    ) -> Option<Message> {
        for i in 0..self.messages.len() {
            if self.messages[i].to == recipient.to {
                let msg = self.messages.remove(i);
                return Some(msg);
            }
        }
        None
    }
}

impl GroundStation {
    fn connect(&self, sat_id: u64) -> CubeSat {
        CubeSat {
            id: sat_id,
        }
    }

    fn send(
        &self, // доступ на чтение GroundStation
        mailbox: &mut Mailbox,  // экземпляр Mailbox будет изменяться
        msg: Message
    ) {
        mailbox.post(msg);
    }
}

impl CubeSat {
    fn recv(
        &self,  // доступ только на чтение CubeSat
        mailbox: &mut Mailbox  // экземпляр Mailbox будет изменяться
    ) -> Option<Message> {
        mailbox.deliver(&self)
    }
}

fn fetch_sat_ids() -> Vec<u64> {
    vec![1, 2, 3]
}

fn main() {
    let mut mail = Mailbox { messages: vec![] };
    
    let base = GroundStation {};
    
    let sat_ids = fetch_sat_ids();
    
    for sat_id in sat_ids {
        let sat = base.connect(sat_id);
        let msg = Message { to: sat_id, content: String::from("hellow")};
        base.send(&mut mail, msg);
    }

    let sat_ids = fetch_sat_ids();
    
    for sat_id in sat_ids {
        let sat = base.connect(sat_id);
        
        let msg = sat.recv(&mut mail);
        println!("{:?}: {:?}", sat, msg);
    }
}
\end{lstlisting}

На Python код выглядел бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import typing as t
from dataclasses import dataclass, field

# В поисках типов код просматривается сверху вниз, поэтому
# приходится вводить служебные типы
_CubeSat = t.NewType("_CubeSat", type)
_Mailbox = t.NewType("_Mailbox", type)

# В Rust это `struct Message`
class Message(t.NamedTuple):
	to: int  # поле
	content: str  # поле

# В Rust это `struct Mailbox` и `impl Mailbox`
@dataclass(frozen=False)
class Mailbox:
	# В Rust это блок struct
	messages: t.List[_Message] = field(default_factory=list)  # NB!

	# В Rust это блок impl
	def post(self, msg: _Message) -> t.NoReturn:
		# Доступ к полю messages экземпляра через self
		self.messages.append(msg)  # эта инструкция изменяет экземпляр дата-класса

	def delivier(self, recipient: _CubeSat) -> t.Optional[Message]:
		for i in range(len(self.messages)):
			if self.messages[i].to == recipient.id:
				msg = self.messages.pop(i)  # эта инстукция изменяет экземпляр дата-класса
				return msg

		return None

# В Rust это `struct CubeSat` и `impl CubeSat`
@dataclass(frozen=False)
class CubeSat:
	id: int  # поле

	def recv(self, mailbox: _Mailbox) -> t.Optional[Message]:
		return mailbox.delivier(self)

def fetch_sat_ids() -> t.List[int]:
	return [1, 2, 3]

# В Rust это `struct GroundStation` и `impl GroundStation`
@dataclass(frozen=False)
class GroundStation:
	# В Rust это блок impl
	def connect(self, sat_id: int) -> CubeSat:
		return CubeSat(id=sat_id)

	def send(self, mailbox: _Mailbox, msg: Message):
		return mailbox.post(msg)


def main():
	mail = Mailbox()
	base = GroundStation()
	sat_ids = fetch_sat_ids()

	for sat_id in sat_ids:
		sat = base.connect(sat_id)
		msg = Message(to=sat_id, content="hello")
		base.send(mail, msg)

	sat_ids = fetch_sat_ids()
	for sat_id in sat_ids:
		sat = base.connect(sat_id)
		msg = sat.recv(mail)
		print(f"{sat}: {msg}")


if __name__ == "__main__":
	main()
\end{lstlisting}

Экземпляр сообщения \texttt{Message} не изменяется после создания, поэтому его можно представить простым именованным кортежем, а не дата-классом. \texttt{Mailbox} приходится представлять дата-классом, потому что поле \texttt{messages} изменяемое. Причем это поле нужно создавать обязательно как \verb|default_factory=list|, чтобы безопасно инициализировать поле экзмепляра пустым списком
\begin{lstlisting}[
style = ironpython,
numbers = none
]
messages: t.List[Message] = field(default_factory=list)
\end{lstlisting}




% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{koltzov-c-lang:2019}{ \emph{Кольцов Д.М.} Си на примерах. Практика, практика и только практика. -- СПб.: Наука и Техника, 2019. -- 288 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
