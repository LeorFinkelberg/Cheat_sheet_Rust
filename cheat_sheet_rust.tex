
\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Практика использования и \\наиболее полезные конструкции языка Rust}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Ресуры по языку Rust}

\url{https://www.rust-lang.org/tools}

\url{https://doc.rust-lang.org/book/}

\url{https://doc.rust-lang.org/stable/rust-by-example/}

\section{Установка Rust}

Установить Rust проще всего с помощью утилиты \texttt{rustup} -- это установщик языка и менеджер версий. Для операционной системы Windows можно скачать \texttt{rustup-init.exe} со страницы проекта \url{https://www.rust-lang.org/learn/get-started}

Установить Rust на Linux можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ curl https://sh.rustup.rs -sSf | bash
...
Current installation options:


default host triple: x86_64-unknown-linux-gnu
default toolchain: stable (default)
profile: default
modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
>1

info: profile set to 'default'
info: default host triple is x86_64-unknown-linux-gnu
info: syncing channel updates for 'stable-x86_64-unknown-linux-gnu'
...
\end{lstlisting}

Rust часто обновляется и чтобы получить последнюю версию, можно воспользоваться командной \texttt{rustup update}.

Собрать проект и обновить его зависимости можно с помощью утилиты \texttt{cargo}
\begin{lstlisting}[
style = bash,
numbers = none
]
cargo build  # build your project
cargo run  # cargo run
cargo test  # test project 
cargo doc  # build documentation for your project
cargo publish  # publish a libarary to crates.io
\end{lstlisting}

То есть \texttt{cargo} знает, как превратить Rust-код в исполняемый бинарный файл, а также может управлять процессом загрузки и компиляции проектных зависимостей.

\section{Вводные замечания}

\emph{Система владения} устанавливает \emph{время жизни} каждого значения, что делает ненужным сборку мусора в ядре языка и обеспечивает надежные, но вместе с тем гибкие интерфейсы для управления такими ресурсами, как сокеты и описатели файлов. Передеча (move) позволяет передавать значение от одного владельца другому, а заимствование (borrowing) -- использовать значение временно, не изменяя владельца.  

Rust -- типобезопасный язык. Но что понимается под типобезопасностью? Ниже приведено определение <<неопределенного поведения>> из стандарта языка С 1999 года, известного под названием <<C99>>: \emph{неопределнное поведение -- это поведение, являющееся следствием использования непереносимой или некорректной программной конструкции либо некорректных данных, для которого в настоящем Международном стандарте нет никаких требований}.

Рассмотрим следующую программу на С
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int main(int argc, char **argv) {
    // объявление одноэлементного массива беззнаковых длинных целых чисел
    unsigned long a[1];
    // обращение к 4-ому элементу массива; индекс, нарушает границу диапазона
    a[3] = 0x7ffff7b36cebUL; 
    return 0;
}
\end{lstlisting}

Эта программа обращается к элементу за концом массива \texttt{a}, поэтому согласно С99 ее \emph{поведение не определно}, т.е. она может делать все что угодно. {\color{red}<<Неопределенная>> операция не просто возвращает неопределнный результат, она дает программе карт-бланш на \emph{произвольное выполнение}(!).}

С99 предоставляет компилятору такое право, чтобы он мог генерировать более быстрый код. Чем возлагать на компилятор ответственность за обнаружение и обработку странного поведения вроде выхода за конец массива, стандарт предполагает, что программист должен позаботиться о том, чтобы такие ситуации никогда не возникали.

Если программа написана так, что ни на каком пути выполнения \emph{неопределенное выполнение невозможно}, то будем говорить, что программа \emph{корректна} (well defined).

Если встроенные в язык проверки \emph{гарантируют корректность программы}, то будем называть язык \emph{типобизопасным} (type safe).

Тщательно напсанная программа на C или C++ может оказаться типобезопасной, {\color{red}но ни C, ни C++ не является типобезопасным языком}: в приведенном выше примере нет ошибок типизации, и тем не менее она демонстрирует неопределенное поведение. С другой стороны, {\color{blue}Python -- \emph{типобезопасный} язык}, его интерпретатор тратит время на обнаружение выхода за границы массива и обрабатывает его лучше, чем компилятор С.

\section{Начало работы}

Создать проект на Rust можно командной \texttt{cargo new <project\_name>}
\begin{lstlisting}[
style = bash,
numbers = none	
]
$ cargo new hello  # создать проект hello
$ tree 
.
hello/
  Cargo.toml
  src/
    main.rs
$ cd hello
$ cargo run  # запустить проект
   Compiling hello v0.1.0 (/home/kosyachenko/Projects/GARBAGE/rust_projects/hello)
Finished dev [unoptimized + debuginfo] target(s) in 0.42s
Running `target/debug/hello`
Hello, world!
# Дерево проекта изменилось
$ tree
.
Cargo.lock  # артефакт
Cargo.toml
src/
  main.rs
target/  # артефакт
  CACHEDIR.TAG
  debug/
    build
    deps/
      hello-27...
      hello-27...d
    examples/
    hello
    hello.d
    incremental/
      hello-imy.../
        s-ghim...
\end{lstlisting}

В основном каталоге имеется файл \texttt{Cargo.toml}, содержащий описание метаданных проекта, таких как имя проекта, его версия и его зависимости. Исходный код попадает в директорию \texttt{src}.

Выполнение команды \texttt{cargo run} привело также к добавлению к проекту новых файлов. Теперь у нас в основном каталоге проекта есть файл \texttt{Cargo.lock} и каталог \texttt{target}. В \texttt{Cargo.lock} указываются конкретные номера версий всех зависимостей, чтобы будущие сборки составлялись точно также, как и эта, пока содержимое \texttt{Cargo.toml} не изменится.

\subsection{Первая программа на Rust}

Нужно как обычно с помощью \texttt{cargo new hello} создать новый проект. Перейти в созданную директорию проекта и в файле \texttt{main.rs} директории \texttt{src} написать следущее
\begin{lstlisting}[			
title = {\sffamily ./src/main.rs},
style = c_cpp,
numbers = none
]
fn greet_world() {
    println!("Hello, world!");
    let southern_germany = "Germany";
    let japan = "Japan";
    let regions = [southern_germany, japan];
    
    for region in regions.iter() {
        println!("{}", &region);
    }
}

fn main() {
    greet_world();
}
\end{lstlisting}

Восклицательный знак свидетельствует об использовании \emph{макроса}. Для операции присваивания в Rust, которую правильнее было бы называть \emph{привязкой переменной}, используется ключевое слово \texttt{let}. Поддержка Unicode предоставляется самим языком. 

Для \emph{литералов массива} используются \emph{квадратные скобки}. Для возврата итератора метод \texttt{iter()} может присутствовать во многих типах. Амперсанд <<заимствует>> \texttt{region} так, чтобы доступ предоставлялся \emph{только для чтения}.

Строки ганатировано получают кодировку UTF-8.

Пример
\begin{lstlisting}[
title = {\sffamily src/main.rs},
style = c_cpp,
numbers = none
]
fn main() {  // (1)
    let penguin_data = "\  // (2)
    common name,length (cm)
    Little penguin,33
    Yellow-eyed penguin,65
    Fiordland penguin,60
    Invalid,data
    ";
    
    let records = penguin_data.lines();
    
    for (i, record) in records.enumerate() {
        if i == 0 || record.trim().len() == 0 {  // (3)
            continue;
        }
    
        let fields: Vec<_> = record  // (4)
            .split(',')  // (5)
            .map(|filed| field.trim())  // (6)
            .collect();  // (7)
            if cfg!(debug_assertations) {  // (8)
                eprintln!("debug: {:?} -> {:?}", record, fields);  // (9)
            }
        
            let name = fields[0];
            if let Ok(length) = fields[1].parse::<f32>() {  // (10)
                println!("{}, {} cm", name, length);  // (11)
            }
    }
}
\end{lstlisting}

(1) -- исполняемым проектам требуется функия \texttt{main()}. (2) -- отключение завершающего символа новой строки. (3) -- пропуск строки заголовка и строк, состоящих из одних пробелов. (4) -- начало со строки текста. (5) -- разбиение записи на поля. (6) -- обрезка пробелов в каждом поле. (7) -- Сборка набора полей. (8) -- \texttt{cfg!} проверяет конфигурацию в процессе компиляции. (9) -- \texttt{eprintln!} выводит данные на страндартное устройство сообщений об ошибках (stderr). (10) -- попытка выполнения парсинга поля в виде числа с плавающей точкой. (11) -- \texttt{println!} помещает данные на страндартное устройство вывода (stdout).

Переменная \texttt{fields} помечена типом \verb|Vec<_>|. \verb|Vec| -- сокращение от \verb|_verctor_|, типа коллекции, способного динамически расширяться. Знак подчеркивания предписывает Rust вывести тип элемента.

На Python решение выглядело бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
#!python
import typing as t

def main():
    penguin_data: str = """
        common name, length (cm)
        Little penguin, 33
        Yellow-eyed penguin, 65
        Fiordland penguin, 60
        Invalid, data
    """
    
    records: t.List[str] = penguin_data.split("\n")
    
    for (i, record) in enumerate(records):
        if i == 0 or len(record.strip()) == 0:
            continue
            
        fields: t.List[str] = list(map(lambda field: field.strip()), records.split(","))
        # Или с помощью спискового включения
        # fields: t.List[str] = [record.strip() for record in records.split(",")]
        
        if __debug__:
            print(f"debug: {record} -> {fields}")
            
        name: str = fields[0]
        # На Rust это блок выглядит изящнее
        try:
            length = float(fields[1])
        except ValueError as err:
            continue
        else:
            print(f"{name}, {length} cm")
            

if __name__ == "__main__":
    main()
\end{lstlisting}

Макросы похожи на функции, но вместо возвращения данных они возвращают код. Макросы часто используются для упрощения общеупотребительных шаблонов. Поле заполнения \verb|{}| заставляет Rust воспользоваться методом представления значения в виде строки, который определил программист, а не представлением по умолчанию, доступным при указании поля заполнителя \verb|{:?}|.

\verb|if let Ok(length) = fields[1].parse::<f32>()| читается так <<попытаться разобрать \texttt{fields[1]} в виде 32-разрядного числа с плавающей точкой, и в случае успеха присвоить число переменной \verb|length|>>.

Конструкция \verb|if let| -- краткий метод обработки данных, предоставляющий также локальную переменную, которой присваиваются эти данные. Метод \verb|parse()| возвращает \texttt{Ok(T)} (где \verb|T| означает любой тип), если ему удается провести разбор строки; в противном случае он возвращает \texttt{Err(E)} (где \texttt{E} означает тип ошибки). Применение \verb|if let Ok(T)| позволяет пропустить любые случаи ошибок, подобные той, что встречаются при обработки строки \texttt{Invalid,data}.

Когда Rust не способен вывести тип из окружающего контекста, он запрашивает конкретное указание. В вызов \verb|parse()| включается встроенная аннотация типа в виде \verb|parse::<f32>()|.

Преобразование исходного кода в исполняемый файл называется \emph{компиляцией}.

В Rust-програмах отсуствуют:
\begin{enumerate}
	\item Висячие указатели -- прямые ссылки на данные, ставшие недействительными в ходе выполнения программы,
	
	\item Состояние гонки -- неспособность из-за изменения внешних факторов определить, как программа будет вести себя от запуска к запуску,
	
	\item Переполнение буфера -- попытка обращения к 12-му элементу массива, состоящего из 6 элементов
\end{enumerate}

В Rust \emph{пустой тип}: \texttt{()} (произносится как <<юнит>>). Когда нет никакого другоо значимого возвращаемого значения, выраженипе возвращает \texttt{()}.

Rust предлагает программистам детальный контроль над размещением структур данных в памяти и над схемами доступа к ним. Временами возникает острая потребность в управлении производительностью приложения. При этом важную роль может сыграть хранение данных в \emph{стеке}, а не в \emph{куче}. 
  
Особые возможности Rust:
\begin{itemize}
	\item Достижение высокой производительности,
	
	\item Выполнение одновременных (параллельных) вычислений,
	
	\item Достижение эффективной работы с памятью.
\end{itemize}

Rust позволяет воспользоваться всей доступной производительностью комьютера. Он не использует для обеспечения безопасности памяти сборщик мусора.

В Rust нет никакой глобальной блокировки интерпретатора, ограничивающей скорость потока.

Единицей компиляции программы на Rust является не отдельный файл, а целый пакет (известный как \emph{крейт}). Поскольку крейты могут включать в себя несколько модулей, они могут становится весьма большими объектами компиляции. Это конечно, позволяет оптимизировать весь крейт, но требует также его компиляции.

\texttt{let} используется для \emph{привязки переменной}. По умолчанию переменные \emph{неизменяемы}, то есть предназначены только для чтения, а не для чтения-записи.

\section{Основы языка}

\subsection{Числа}

Преобразования между типами всегда носят явный характер. В Rust у чисел могут быть методы: например, для округления \texttt{24.5} к ближайшему целому числу используется \verb|24.5_f32.round()|, а не \verb|round(24.5)|.

Литералы чисел с плавающей точкой без явно указанной аннотации типа становятся 32- или 64-разрядными в зависимости от контекста.

Имеющиеся в Rust требования к безопасности типов \emph{не позволяют проводить сравнение между типами}. Например, следующий код не пройдет компиляцию:
\begin{lstlisting}[
style = c_cpp,
numbers = none,
]
fn main() {
    let a: i32 = 10;
    let b: u16 = 100;
    
    if a < b {  // error[E0308]: mismatched types
        println!("Ten is less then one hundred.")
    }
}
\end{lstlisting} 

Безопаснее всего привести меньший тип к большему (например, 16-разрядный тип к 32-разрядному): \verb|(b as i32)|. Иногда это называют расширением.

Порой использовать ключевое слово \texttt{as} накладывает слишком большие ограничения. В следущем листинге показан Rust-метод, заменяющий ключевое слово \texttt{as} в тех случаях, когда приведение может дать сбой
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use std::convert::TryInto;

fn main() {
    let a: i32 = 10;
    let b: u16 = 100;
    
    let b_ = b.try_into().unwrap();  // try_into() -> тип Result
    
    if a < b_ {
        println!("Ten is less than one hundred.");
    }
}
\end{lstlisting}

Ключевое слово \texttt{use} переносит типаж \verb|std::convert::TryInto| в локальную область видимости. В результате этого происходит разблокирование метода \verb|try_into()|, вызываемого в отношении переменной \texttt{b}. 

\emph{Типажи} можно рассматривать как \emph{абстрактные классы} или \emph{интерфейсы}. Метод \verb|b.try_into()| возвращает значение типа \verb|i32|, завернутое в значение типа \texttt{Result}. Значение успеха может быть обработано методом \verb|unwrap()|, в результате чего здесь будет возвращено значение \texttt{b}, имеющее тип \verb|i32|.

Rust включает ряд допуско, позволяющих сравнивать числовые значения с плавающей точкой. Эти допуски определяются как \verb|f32::EPSILON| и \verb|f64::EPSILON|.

Операции, выдающие математически неопределенные результаты, например извлечение квадратного корня из отрицательного числа, создают особые проблемы. Для обработки таких случаев в тип числа с плавающей точкой включены знаения NaN -- <<not a number>>.

Чтобы добавить контейнер (крейт) в проект достаточно добавить в раздел \texttt{[dependencies]}имя крейта и его версию в файл \texttt{Cargo.toml}
\begin{lstlisting}[
title = {\sffamily Cargo.toml},
style = bash,
numbers = none
]
...
[dependencies]
num = "0.4"
...
\end{lstlisting}

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use num::complex::Complex;

fn main() {
    let a = Complex {re: 2.1, im: -1.2};  // у каждого типа в Rust имеется литеральный синтаксис
    let b = Complex::new(11.1, 22.2);
    let result = a + b;
    
    println!("{} + {}i", result.re, result.im);  // доступ к полям через оператор точка
}
\end{lstlisting}

Ключевое слово \texttt{use} помещает тип \texttt{Complex} в локальную область видимости. В Rust нет конструкторов, вместо этого у каждого типа есть литеральная форма.

Инициализировать типы можно путем использования имени типа и присвоения его полям значений в фигурных скобках: \verb|Complex { re: 2.1, im: -1.2 }|. Для упрощения программ метод \verb|new()| реализован у многих типов. Но это соглашение не часть языка Rust.

Поддерживаются две форму инициализации неэлементарных типов:
\begin{itemize}
	\item Литеральный синтаксис: \verb|Complex { re: 2.1, im: -1.2 }|,
	
	\item Статическим методом \verb|new()|: \verb|Complex::new(11.1, 22.2)|.
\end{itemize}

Статический метод -- это функция, доступная для \emph{типа}, но не для \emph{экземпляра типа}. В реальном коде предпочтительнее вторая форма.

\subsection{Управление ходом выполнения программы}

Базовая форма цикла \texttt{for} имеет следующий вид
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for item in container {
    // ...
}
\end{lstlisting}

Эта базовая форма делает каждый последующий элемент в контейнере \texttt{container} доступным в качестве элемента \texttt{item}.

Несмотря, на то, что переменная \texttt{container} остается в локальной области видимости, теперь ее \emph{время жизни} истекло. Rust считает, что раз блок закончился, то надобности в переменной \texttt{container} миновала.

Когда чуть позже в программе возникнет желание воспользоваться переменной \texttt{container} еще раз, следует воспользоваться указателем. Когда указатель опущен, Rust полагает, что переменная \texttt{container} больше не нужна. Чтобы добавить \emph{указатель} на контейнер, нужно, как показано в следующем примере, поставить перед его именем знак амперсанда (\verb|&|)
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for item in &container {
    // ...
}
\end{lstlisting}

Если в ходе циклического перебора элементов нужно внести изменения в каждый элемент, можно воспользоваться \emph{указателем}, \emph{допускающим изменения}, включив в код ключевое слово \texttt{mut}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for item in &mut container {
    // ...
}
\end{lstlisting}

\emph{Безымянные циклы}. Если в блоке не используется локальная переменная, то по соглашению применяется знак подчеркивания <<\verb|_|>>. Использование этой схемы в сочетании с синтаксисом \emph{исключающего диапазона} (\verb|n..m|) и синтаксисом \emph{включающего диапазона} (\verb|n..=m|) показывает, что целью является выполнение цикла фиксированное количество раз. Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for _ in 0..10 {
    // ...
}
\end{lstlisting}

Ключевое слово \texttt{continue} действует вполне ожидаемым образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// Вывести только нечетные 
for item in 0..10 {
    if item % 2 == 0 {
        continue;
    }
}
\end{lstlisting}

Прерывание цикла выполняется с помощью ключевого слова \texttt{break}. При этом Rust работает превычным образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn main() {
    for (x, y) in (0..).zip(0..) { // zip работает на бесконечной последовательности
        if x + y > 100 {
            break;
        }
        println!("x={}, y={}", x, y);
    }
}
\end{lstlisting}

В Python пришлось бы организовывать бесконечный цикл \texttt{while}, например так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def main():
    x, y = (0, 0)
    while True:
        if x + y > 100:
            break
        print(f"x={x}, y={y}")
        x += 1
        y += 1
\end{lstlisting}

Прерывание во вложенных циклах. Прервать выполнение вложенного цикла можно с помощью \emph{меток циклов}. Метка цикла представляет собой идентификатор с префиксом в виде \emph{апострофа} \verb|'|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
`outer: for x in 0.. {
    for y in 0.. {
        for z in 0.. {
            if x + y + z > 10 {
                break `outer;
            }
            // ...
        }
    }
}
\end{lstlisting}

Условное ветвление. \texttt{if} допускает применение любого выражения, вычисленного в булево значение (\texttt{true} или \texttt{false}). Когда нужно протестировать несколько значений, можно добавить цепочку блоков \texttt{if else}. Блок \texttt{else} соответствует всему, чему еще не нашлось соответствие. Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
if item == 42 {
    // ...
} else if item == 132 {
    // ...
} else {
    // ...
}
\end{lstlisting}

В Rust отсутствует концепция <<правдивых>> или <<ложных>> типов. В других языках (например, в Python) допускается, чтобы особые значения, например 0 или пустая строка, означали \texttt{false}, а другие значения означали \texttt{true}, но в Rust это не практикуется. Единственным значением, которое может быть \texttt{true}, является \texttt{true}, а за \texttt{false} может принимать только \texttt{false}.












% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{koltzov-c-lang:2019}{ \emph{Кольцов Д.М.} Си на примерах. Практика, практика и только практика. -- СПб.: Наука и Техника, 2019. -- 288 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
