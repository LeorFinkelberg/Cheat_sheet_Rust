
\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Практика использования и \\наиболее полезные конструкции языка Rust}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Ресуры по языку Rust}

\url{https://www.rust-lang.org/tools}

\url{https://doc.rust-lang.org/book/}

\url{https://doc.rust-lang.org/stable/rust-by-example/}

\section{Troubleshooting}

\subsection{Unable to find libclang: could't find any valid shared libraies ...}

Больше полезной информации можно получить по ссылке \url{https://esp-rs.github.io/book/installation/troubleshooting.html}

Ошибка
\begin{lstlisting}[
numbers = none	
]
thread 'main' panicked at 'Unable to find libclang: "couldn't find any valid shared libraries matching: ['libclang.so', 'libclang-*.so', 'libclang.so.*', 'libclang-*.so.*'], set the `LIBCLANG_PATH` environment variable to a path where one of these files can be found (invalid: [])"', /home/esp/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.60.1/src/lib.rs:2172:31
\end{lstlisting}

Нам нужно LIBCLANG для bindgen, чтобы сгенерировать привязки Rust к заголовкам ESP-IDF C. Нужно убедиться, что переменная окружения \verb|LIBCLANG_PATH| установлена и указывает на пользовательский LLVM

LLVM (Low Level Virtual Machine) -- проект программной инфраструктуры для создания компиляторов и сопутсвующих им утилит. 

Clang (произносится <<кленг>>) -- транслятор для С-подобных языков, созданный специально для работы на базе LLVM. Комбинация Clang и LLVM представляет собой полноценный компилятор и предоставляет набор инструментов, позволяющих полностью заменить GCC.

Установить LLVM на Linux Centos 7 \url{https://nanomode.ru/how/kak-ustanovit-llvm-na-centos7/} можно так. Более старая версия LLVM доступна в официальном репозитории дополнительных компонентов на Centos 7. Но при желании можно загрузить и установить последнюю версию LLVM по адресу \url{http://llvm.org}.

Самый простой способ установить библиотеки C и C++ для LLVM Clang -- это установить \verb|gcc| и \verb|g++| на Centos 7
\begin{lstlisting}[
style = bash,
numbers = none
]
$ sudo yum makecache
$ sudo yum install gcc gcc-c++
\end{lstlisting}

LLVM Clang версии 3.4.2 доступен в операционной системе Centos 7 в репозитории \verb|extras|
\begin{lstlisting}[
style = bash,
numbers = none
]
sudo yum info clang
\end{lstlisting}

Вывести список всех включенных репозиториев Centos 7
\begin{lstlisting}[
style = bash,
numbers = none
]
sudo yum repolist
\end{lstlisting}

Если репозиторий \verb|extras| не включен в Centos 7, то нужно сделать следущее
\begin{lstlisting}[
style = bash,
numbers = none	
]
sudo yum install yum-utils
sudo yum-config-manager --enable extras
\end{lstlisting}

Обновить кэш репозитория пакетов \verb|yum| 
\begin{lstlisting}[
style = bash,
numbers = none
]
sudo yum makecache
\end{lstlisting}

Установить LLVM Clang
\begin{lstlisting}[
style = bash,
numbers = none
]
sudo yum install clang
\end{lstlisting}

Проверка
\begin{lstlisting}[
style = bash,
numbers = none
]
clang --version
# clang version 3.4.2 (tags/RELEASE_34/dot2-final)
# Target: x86_64-redhat-linux-gnu
# Thread model: posix
\end{lstlisting}





\section{Установка Rust}

Установить Rust проще всего с помощью утилиты \texttt{rustup} -- это установщик языка и менеджер версий. Для операционной системы Windows можно скачать \texttt{rustup-init.exe} со страницы проекта \url{https://www.rust-lang.org/learn/get-started}

Установить Rust на Linux можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ curl https://sh.rustup.rs -sSf | bash
...
Current installation options:


default host triple: x86_64-unknown-linux-gnu
default toolchain: stable (default)
profile: default
modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
>1

info: profile set to 'default'
info: default host triple is x86_64-unknown-linux-gnu
info: syncing channel updates for 'stable-x86_64-unknown-linux-gnu'
...
\end{lstlisting}

Rust часто обновляется и чтобы получить последнюю версию, можно воспользоваться командной \texttt{rustup update}.

Собрать проект и обновить его зависимости можно с помощью утилиты \texttt{cargo}
\begin{lstlisting}[
style = bash,
numbers = none
]
cargo build  # build your project
cargo run  # cargo run
cargo test  # test project 
cargo doc  # build documentation for your project
cargo publish  # publish a libarary to crates.io
\end{lstlisting}

То есть \texttt{cargo} знает, как превратить Rust-код в исполняемый бинарный файл, а также может управлять процессом загрузки и компиляции проектных зависимостей.

\section{Вводные замечания}

\emph{Система владения} устанавливает \emph{время жизни} каждого значения, что делает ненужным сборку мусора в ядре языка и обеспечивает надежные, но вместе с тем гибкие интерфейсы для управления такими ресурсами, как сокеты и описатели файлов. Передеча (move) позволяет передавать значение от одного владельца другому, а заимствование (borrowing) -- использовать значение временно, не изменяя владельца.  

Rust -- типобезопасный язык. Но что понимается под типобезопасностью? Ниже приведено определение <<неопределенного поведения>> из стандарта языка С 1999 года, известного под названием <<C99>>: \emph{неопределнное поведение -- это поведение, являющееся следствием использования непереносимой или некорректной программной конструкции либо некорректных данных, для которого в настоящем Международном стандарте нет никаких требований}.

Рассмотрим следующую программу на С
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int main(int argc, char **argv) {
    // объявление одноэлементного массива беззнаковых длинных целых чисел
    unsigned long a[1];
    // обращение к 4-ому элементу массива; индекс, нарушает границу диапазона
    a[3] = 0x7ffff7b36cebUL; 
    return 0;
}
\end{lstlisting}

Эта программа обращается к элементу за концом массива \texttt{a}, поэтому согласно С99 ее \emph{поведение не определно}, т.е. она может делать все что угодно. {\color{red}<<Неопределенная>> операция не просто возвращает неопределнный результат, она дает программе карт-бланш на \emph{произвольное выполнение}(!).}

С99 предоставляет компилятору такое право, чтобы он мог генерировать более быстрый код. Чем возлагать на компилятор ответственность за обнаружение и обработку странного поведения вроде выхода за конец массива, стандарт предполагает, что программист должен позаботиться о том, чтобы такие ситуации никогда не возникали.

Если программа написана так, что ни на каком пути выполнения \emph{неопределенное выполнение невозможно}, то будем говорить, что программа \emph{корректна} (well defined).

Если встроенные в язык проверки \emph{гарантируют корректность программы}, то будем называть язык \emph{типобизопасным} (type safe).

Тщательно напсанная программа на C или C++ может оказаться типобезопасной, {\color{red}но ни C, ни C++ не является типобезопасным языком}: в приведенном выше примере нет ошибок типизации, и тем не менее она демонстрирует неопределенное поведение. С другой стороны, {\color{blue}Python -- \emph{типобезопасный} язык}, его интерпретатор тратит время на обнаружение выхода за границы массива и обрабатывает его лучше, чем компилятор С.

\section{Начало работы}

Создать проект на Rust можно командной \texttt{cargo new <project\_name>}
\begin{lstlisting}[
style = bash,
numbers = none	
]
$ cargo new hello  # создать проект hello
$ tree 
.
hello/
  Cargo.toml
  src/
    main.rs
$ cd hello
$ cargo run  # запустить проект
   Compiling hello v0.1.0 (/home/kosyachenko/Projects/GARBAGE/rust_projects/hello)
Finished dev [unoptimized + debuginfo] target(s) in 0.42s
Running `target/debug/hello`
Hello, world!
# Дерево проекта изменилось
$ tree
.
Cargo.lock  # артефакт
Cargo.toml
src/
  main.rs
target/  # артефакт
  CACHEDIR.TAG
  debug/
    build
    deps/
      hello-27...
      hello-27...d
    examples/
    hello
    hello.d
    incremental/
      hello-imy.../
        s-ghim...
\end{lstlisting}

В основном каталоге имеется файл \texttt{Cargo.toml}, содержащий описание метаданных проекта, таких как имя проекта, его версия и его зависимости. Исходный код попадает в директорию \texttt{src}.

Выполнение команды \texttt{cargo run} привело также к добавлению к проекту новых файлов. Теперь у нас в основном каталоге проекта есть файл \texttt{Cargo.lock} и каталог \texttt{target}. В \texttt{Cargo.lock} указываются конкретные номера версий всех зависимостей, чтобы будущие сборки составлялись точно также, как и эта, пока содержимое \texttt{Cargo.toml} не изменится.

\subsection{Первая программа на Rust}

Нужно как обычно с помощью \texttt{cargo new hello} создать новый проект. Перейти в созданную директорию проекта и в файле \texttt{main.rs} директории \texttt{src} написать следущее
\begin{lstlisting}[			
title = {\sffamily ./src/main.rs},
style = c_cpp,
numbers = none
]
fn greet_world() {
    println!("Hello, world!");
    let southern_germany = "Germany";
    let japan = "Japan";
    let regions = [southern_germany, japan];
    
    for region in regions.iter() {
        println!("{}", &region);
    }
}

fn main() {
    greet_world();
}
\end{lstlisting}

Восклицательный знак свидетельствует об использовании \emph{макроса}. Для операции присваивания в Rust, которую правильнее было бы называть \emph{привязкой переменной}, используется ключевое слово \texttt{let}. Поддержка Unicode предоставляется самим языком. 

Для \emph{литералов массива} используются \emph{квадратные скобки}. Для возврата итератора метод \texttt{iter()} может присутствовать во многих типах. Амперсанд <<заимствует>> \texttt{region} так, чтобы доступ предоставлялся \emph{только для чтения}.

Строки ганатировано получают кодировку UTF-8.

Пример
\begin{lstlisting}[
title = {\sffamily src/main.rs},
style = c_cpp,
numbers = none
]
fn main() {  // (1)
    let penguin_data = "\  // (2)
    common name,length (cm)
    Little penguin,33
    Yellow-eyed penguin,65
    Fiordland penguin,60
    Invalid,data
    ";
    
    let records = penguin_data.lines();
    
    for (i, record) in records.enumerate() {
        if i == 0 || record.trim().len() == 0 {  // (3)
            continue;
        }
    
        let fields: Vec<_> = record  // (4)
            .split(',')  // (5)
            .map(|filed| field.trim())  // (6)
            .collect();  // (7)
            if cfg!(debug_assertations) {  // (8)
                eprintln!("debug: {:?} -> {:?}", record, fields);  // (9)
            }
        
            let name = fields[0];
            if let Ok(length) = fields[1].parse::<f32>() {  // (10)
                println!("{}, {} cm", name, length);  // (11)
            }
    }
}
\end{lstlisting}

(1) -- исполняемым проектам требуется функия \texttt{main()}. (2) -- отключение завершающего символа новой строки. (3) -- пропуск строки заголовка и строк, состоящих из одних пробелов. (4) -- начало со строки текста. (5) -- разбиение записи на поля. (6) -- обрезка пробелов в каждом поле. (7) -- Сборка набора полей. (8) -- \texttt{cfg!} проверяет конфигурацию в процессе компиляции. (9) -- \texttt{eprintln!} выводит данные на страндартное устройство сообщений об ошибках (stderr). (10) -- попытка выполнения парсинга поля в виде числа с плавающей точкой. (11) -- \texttt{println!} помещает данные на страндартное устройство вывода (stdout).

Переменная \texttt{fields} помечена типом \verb|Vec<_>|. \verb|Vec| -- сокращение от \verb|_verctor_|, типа коллекции, способного динамически расширяться. Знак подчеркивания предписывает Rust вывести тип элемента.

На Python решение выглядело бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
#!python
import typing as t

def main():
    penguin_data: str = """
        common name, length (cm)
        Little penguin, 33
        Yellow-eyed penguin, 65
        Fiordland penguin, 60
        Invalid, data
    """
    
    records: t.List[str] = penguin_data.split("\n")
    
    for (i, record) in enumerate(records):
        if i == 0 or len(record.strip()) == 0:
            continue
            
        fields: t.List[str] = list(map(lambda field: field.strip()), records.split(","))
        # Или с помощью спискового включения
        # fields: t.List[str] = [record.strip() for record in records.split(",")]
        
        if __debug__:
            print(f"debug: {record} -> {fields}")
            
        name: str = fields[0]
        # На Rust это блок выглядит изящнее
        try:
            length = float(fields[1])
        except ValueError as err:
            continue
        else:
            print(f"{name}, {length} cm")
            

if __name__ == "__main__":
    main()
\end{lstlisting}

Макросы похожи на функции, но вместо возвращения данных они возвращают код. Макросы часто используются для упрощения общеупотребительных шаблонов. Поле заполнения \verb|{}| заставляет Rust воспользоваться методом представления значения в виде строки, который определил программист, а не представлением по умолчанию, доступным при указании поля заполнителя \verb|{:?}|.

\verb|if let Ok(length) = fields[1].parse::<f32>()| читается так <<попытаться разобрать \texttt{fields[1]} в виде 32-разрядного числа с плавающей точкой, и в случае успеха присвоить число переменной \verb|length|>>.

Конструкция \verb|if let| -- краткий метод обработки данных, предоставляющий также локальную переменную, которой присваиваются эти данные. Метод \verb|parse()| возвращает \texttt{Ok(T)} (где \verb|T| означает любой тип), если ему удается провести разбор строки; в противном случае он возвращает \texttt{Err(E)} (где \texttt{E} означает тип ошибки). Применение \verb|if let Ok(T)| позволяет пропустить любые случаи ошибок, подобные той, что встречаются при обработки строки \texttt{Invalid,data}.

Когда Rust не способен вывести тип из окружающего контекста, он запрашивает конкретное указание. В вызов \verb|parse()| включается встроенная аннотация типа в виде \verb|parse::<f32>()|.

Преобразование исходного кода в исполняемый файл называется \emph{компиляцией}.

В Rust-програмах отсуствуют:
\begin{enumerate}
	\item Висячие указатели -- прямые ссылки на данные, ставшие недействительными в ходе выполнения программы,
	
	\item Состояние гонки -- неспособность из-за изменения внешних факторов определить, как программа будет вести себя от запуска к запуску,
	
	\item Переполнение буфера -- попытка обращения к 12-му элементу массива, состоящего из 6 элементов
\end{enumerate}

В Rust \emph{пустой тип}: \texttt{()} (произносится как <<юнит>>). Когда нет никакого другоо значимого возвращаемого значения, выраженипе возвращает \texttt{()}.

Rust предлагает программистам детальный контроль над размещением структур данных в памяти и над схемами доступа к ним. Временами возникает острая потребность в управлении производительностью приложения. При этом важную роль может сыграть хранение данных в \emph{стеке}, а не в \emph{куче}. 
  
Особые возможности Rust:
\begin{itemize}
	\item Достижение высокой производительности,
	
	\item Выполнение одновременных (параллельных) вычислений,
	
	\item Достижение эффективной работы с памятью.
\end{itemize}

Rust позволяет воспользоваться всей доступной производительностью комьютера. Он не использует для обеспечения безопасности памяти сборщик мусора.

В Rust нет никакой глобальной блокировки интерпретатора, ограничивающей скорость потока.

Единицей компиляции программы на Rust является не отдельный файл, а целый пакет (известный как \emph{крейт}). Поскольку крейты могут включать в себя несколько модулей, они могут становится весьма большими объектами компиляции. Это конечно, позволяет оптимизировать весь крейт, но требует также его компиляции.

\texttt{let} используется для \emph{привязки переменной}. По умолчанию переменные \emph{неизменяемы}, то есть предназначены только для чтения, а не для чтения-записи.

\section{Основы языка}

\subsection{Числа}

Преобразования между типами всегда носят явный характер. В Rust у чисел могут быть методы: например, для округления \texttt{24.5} к ближайшему целому числу используется \verb|24.5_f32.round()|, а не \verb|round(24.5)|.

Литералы чисел с плавающей точкой без явно указанной аннотации типа становятся 32- или 64-разрядными в зависимости от контекста.

Имеющиеся в Rust требования к безопасности типов \emph{не позволяют проводить сравнение между типами}. Например, следующий код не пройдет компиляцию:
\begin{lstlisting}[
style = c_cpp,
numbers = none,
]
fn main() {
    let a: i32 = 10;
    let b: u16 = 100;
    
    if a < b {  // error[E0308]: mismatched types
        println!("Ten is less then one hundred.")
    }
}
\end{lstlisting} 

Безопаснее всего привести меньший тип к большему (например, 16-разрядный тип к 32-разрядному): \verb|(b as i32)|. Иногда это называют расширением.

Порой использовать ключевое слово \texttt{as} накладывает слишком большие ограничения. В следущем листинге показан Rust-метод, заменяющий ключевое слово \texttt{as} в тех случаях, когда приведение может дать сбой
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use std::convert::TryInto;

fn main() {
    let a: i32 = 10;
    let b: u16 = 100;
    
    let b_ = b.try_into().unwrap();  // try_into() -> тип Result
    
    if a < b_ {
        println!("Ten is less than one hundred.");
    }
}
\end{lstlisting}

Ключевое слово \texttt{use} переносит типаж \verb|std::convert::TryInto| в локальную область видимости. В результате этого происходит разблокирование метода \verb|try_into()|, вызываемого в отношении переменной \texttt{b}. 

\emph{Типажи} можно рассматривать как \emph{абстрактные классы} или \emph{интерфейсы}. Метод \verb|b.try_into()| возвращает значение типа \verb|i32|, завернутое в значение типа \texttt{Result}. Значение успеха может быть обработано методом \verb|unwrap()|, в результате чего здесь будет возвращено значение \texttt{b}, имеющее тип \verb|i32|.

Rust включает ряд допуско, позволяющих сравнивать числовые значения с плавающей точкой. Эти допуски определяются как \verb|f32::EPSILON| и \verb|f64::EPSILON|.

Операции, выдающие математически неопределенные результаты, например извлечение квадратного корня из отрицательного числа, создают особые проблемы. Для обработки таких случаев в тип числа с плавающей точкой включены знаения NaN -- <<not a number>>.

Чтобы добавить контейнер (крейт) в проект достаточно добавить в раздел \texttt{[dependencies]}имя крейта и его версию в файл \texttt{Cargo.toml}
\begin{lstlisting}[
title = {\sffamily Cargo.toml},
style = bash,
numbers = none
]
...
[dependencies]
num = "0.4"
...
\end{lstlisting}

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use num::complex::Complex;

fn main() {
    let a = Complex {re: 2.1, im: -1.2};  // у каждого типа в Rust имеется литеральный синтаксис
    let b = Complex::new(11.1, 22.2);
    let result = a + b;
    
    println!("{} + {}i", result.re, result.im);  // доступ к полям через оператор точка
}
\end{lstlisting}

Ключевое слово \texttt{use} помещает тип \texttt{Complex} в локальную область видимости. В Rust нет конструкторов, вместо этого у каждого типа есть литеральная форма.

Инициализировать типы можно путем использования имени типа и присвоения его полям значений в фигурных скобках: \verb|Complex { re: 2.1, im: -1.2 }|. Для упрощения программ метод \verb|new()| реализован у многих типов. Но это соглашение не часть языка Rust.

Поддерживаются две форму инициализации неэлементарных типов:
\begin{itemize}
	\item Литеральный синтаксис: \verb|Complex { re: 2.1, im: -1.2 }|,
	
	\item Статическим методом \verb|new()|: \verb|Complex::new(11.1, 22.2)|.
\end{itemize}

Статический метод -- это функция, доступная для \emph{типа}, но не для \emph{экземпляра типа}. В реальном коде предпочтительнее вторая форма.

\subsection{Управление ходом выполнения программы}

Базовая форма цикла \texttt{for} имеет следующий вид
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for item in container {
    // ...
}
\end{lstlisting}

Эта базовая форма делает каждый последующий элемент в контейнере \texttt{container} доступным в качестве элемента \texttt{item}.

Несмотря, на то, что переменная \texttt{container} остается в локальной области видимости, теперь ее \emph{время жизни} истекло. Rust считает, что раз блок закончился, то надобности в переменной \texttt{container} миновала.

Когда чуть позже в программе возникнет желание воспользоваться переменной \texttt{container} еще раз, следует воспользоваться указателем. Когда указатель опущен, Rust полагает, что переменная \texttt{container} больше не нужна. Чтобы добавить \emph{указатель} на контейнер, нужно, как показано в следующем примере, поставить перед его именем знак амперсанда (\verb|&|)
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for item in &container {
    // ...
}
\end{lstlisting}

Если в ходе циклического перебора элементов нужно внести изменения в каждый элемент, можно воспользоваться \emph{указателем}, \emph{допускающим изменения}, включив в код ключевое слово \texttt{mut}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for item in &mut container {
    // ...
}
\end{lstlisting}

\emph{Безымянные циклы}. Если в блоке не используется локальная переменная, то по соглашению применяется знак подчеркивания <<\verb|_|>>. Использование этой схемы в сочетании с синтаксисом \emph{исключающего диапазона} (\verb|n..m|) и синтаксисом \emph{включающего диапазона} (\verb|n..=m|) показывает, что целью является выполнение цикла фиксированное количество раз. Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
for _ in 0..10 {
    // ...
}
\end{lstlisting}

Ключевое слово \texttt{continue} действует вполне ожидаемым образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// Вывести только нечетные 
for item in 0..10 {
    if item % 2 == 0 {
        continue;
    }
}
\end{lstlisting}

Прерывание цикла выполняется с помощью ключевого слова \texttt{break}. При этом Rust работает превычным образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn main() {
    for (x, y) in (0..).zip(0..) { // zip работает на бесконечной последовательности
        if x + y > 100 {
            break;
        }
        println!("x={}, y={}", x, y);
    }
}
\end{lstlisting}

В Python пришлось бы организовывать бесконечный цикл \texttt{while}, например так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def main():
    x, y = (0, 0)
    while True:
        if x + y > 100:
            break
        print(f"x={x}, y={y}")
        x += 1
        y += 1
\end{lstlisting}

Прерывание во вложенных циклах. Прервать выполнение вложенного цикла можно с помощью \emph{меток циклов}. Метка цикла представляет собой идентификатор с префиксом в виде \emph{апострофа} \verb|'|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
`outer: for x in 0.. {
    for y in 0.. {
        for z in 0.. {
            if x + y + z > 10 {
                break `outer;
            }
            // ...
        }
    }
}
\end{lstlisting}

Условное ветвление. \texttt{if} допускает применение любого выражения, вычисленного в булево значение (\texttt{true} или \texttt{false}). Когда нужно протестировать несколько значений, можно добавить цепочку блоков \texttt{if else}. Блок \texttt{else} соответствует всему, чему еще не нашлось соответствие. Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
if item == 42 {
    // ...
} else if item == 132 {
    // ...
} else {
    // ...
}
\end{lstlisting}

В Rust отсутствует концепция <<правдивых>> или <<ложных>> типов. В других языках (например, в Python) допускается, чтобы особые значения, например 0 или пустая строка, означали \texttt{false}, а другие значения означали \texttt{true}, но в Rust это не практикуется. Единственным значением, которое может быть \texttt{true}, является \texttt{true}, а за \texttt{false} может принимать только \texttt{false}.

Rust -- язык, основанный на выражениях. Для Rust характерно обходится без ключевого слова \texttt{return}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn is_even(n: i32) -> bool {
    n % 2 == 0
}

fn main() {
    let n: i32 = 123456;
    let description = if is_even(n) {
        "even"
    } else {
        "odd"
    };

    prinln!("n={} is {}", n, description);
}
\end{lstlisting}

Этот прием может распространяться и на другие блоки, включая \texttt{match}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn is_even(n: i32) -> bool {
    n % 2 == 0
}

fn main() {
    lst n = 654321;
    let description = match is_even(n) {
        true => "even",
        false => "odd",
    };

    println!("n={} is {}", n, description);
}
\end{lstlisting}

\subsection{Расширенные определения функций}

Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
fn add_with_lifetimes<'a, 'b>(i: &'a i32, j: &'b i32) -> i32 {
    *i + *j
}
\end{lstlisting}
\begin{itemize}
	\item \verb|fn add_with_lifetimes(...) -> i32| -- функция, возвращающая значение типа \verb|i32|,
	
	\item \verb|<'a, 'b>| -- объявление двух \emph{переменных времени жизни}, \verb|'a| и \verb|'b|, в области видимости функции \verb|add_with_lifetimes()|. Обычно о них говорят как о \emph{времени жизни} \emph{a} и \emph{времени жизни}~\emph{b},
	
	\item \verb|i: &'a i32| -- привязка {\color{blue}\emph{переменной времени жизни} \verb|'a|} к времени жизни \texttt{i}. Этот синтаксис читается так <<параметр \texttt{i} является \emph{указателем} на \verb|i32| с {\color{blue}временем жизни \emph{a}}>>,
	
	\item \verb|j: &'b i32| -- привязка {\color{blue}\emph{переменной времени жизни} \verb|'b|} к времени жизни \texttt{j}. Этот синтаксис читается так <<параметр \texttt{j} является \emph{указателем} на \verb|i32| с {\color{blue}времнем жизни \emph{b}}>>.
\end{itemize}

Основа проводимых в Rust проверок безопасности -- система времени жизни, позволяющая убедиться, что все попытки обращения к данным являются допустимыми. Все значения, привязанные к данному времени жизни, должны существовать вплоть до последнего доступа к любому значению, привязанному к этому же времени жизни.

Обычно система времени жизни работает без посторонней помощи. Хотя время жизни есть почти у каждого параметра, проверки в основном проходят скрытно, поскольку компилятор может определить время жизни самостоятельно. Но в сложных случаях компилятору нужна помощь.

При вызове функции аннотации времени жизни не требуются. 
\begin{lstlisting}[
style = bash,
numbers = none
]
fn add_with_lifetimes<'a, 'b>(i: &'a i32, j: &'b i32) -> i32 {
    *i + *j  // (1)
}

fn main() {
    let a = 10;
    let b = 20;
    let res = add_with_lifetimes(&a, &b);  // (2)
    println!("{}", res);
}
\end{lstlisting}

(1) -- сложение значений, на которые указывают \texttt{i} и \texttt{j}, а не сложение непосредственно самих указателей. (2) -- \verb|&a| и \verb|&b| означают \emph{указатели} соответственно на 10 и 20.

Использование двух параметров времени жизни (\texttt{a} и \texttt{b}) показывает, что времени жизни \texttt{i} и \texttt{j} не связаны друг с другом.

\subsubsection{Обобщенные функции}

Типовая сигнатура обобщенной функции
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn add<T>(i: T, j: T) -> T {
    i + j
}
\end{lstlisting}

\emph{Переменная типа} \texttt{T} вводится в угловых скобках (\verb|<T>|). Эта функция принимает два аргумента одного и того же типа и возврщает значение такого же типа.

Заглавные буквы вместо типа указывают на \emph{обобщенный тип}. В соответствие с действующим соглашением в качестве заместителей используются произвольно выбираемые переменные \texttt{T}, \texttt{U} и \texttt{V}. А переменная \texttt{E} часто применяется для обозначения типа ошибки.

Обобщения позволяют использовать код многократно и могут существенно повысить удобство работы со строго типизированными языками.

Все Rust-операторы, включая сложение, определены в \emph{типажах}. Чтобы выставить требование, что тип \texttt{T} должен поддерживать сложение, в определение функции наряду с переменной типа включается \emph{типажное ограничение}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// std::ops::Add -- типаж
fn add<T: std::ops::Add<Output = T>>(i: T, j: T) -> T {
    i + j
}
\end{lstlisting}

Фрагмент \verb|<T: std::ops::Add<Output = T>>| предписывает, что в \texttt{T} должна быть реализация операции \verb|std::ops::Add|. Использование одной и той же переменной типа \texttt{T} с типажными ограничением гарантирует, что агрументы \texttt{i} и \texttt{j}, а также возвращемое значение будут одного и того же типа и их типы поддеживают сложение.

\emph{Типаж} -- это что-то вроде \emph{абстактного базового класса}. Все Rust-операции определяются с помощью типажей. Например, оператор сложения (+) определен как типаж \verb|std::ops::Add|.

Все Rust-операторы являются удобным синтаксическим примемом для вызова \emph{методов типажей}. В ходе компиляции выполняется преобразование выражения \verb*|a + b| в \verb|a.add(b)|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use std::ops::{Add};
use std::time::{Duration};

fn add<T: Add<Output = T>>(i: T, j: T) -> {
    j + j
}

fn main() {
    let floats = add(1.2, 3.2);
    let ints = add(10, 20);
    let duratoins = add(
        Duration::new(5, 0),
        Duration::new(10, 0)
    );
    
    println!("{}", floats);
    println!("{}", ints);
    println!("{:?}", durations);
}
\end{lstlisting}

\subsection{Создание списков с использованием массивов, слайсов и векторов}

\subsubsection{Массивы}

\emph{Массивы} характеризуются фиксированной шириной и чрезвычайной скромностью в потреблении ресурсов. \emph{Векторы} можно наращивать, но им свойственны издержки времени выполнения из-зи ведения дополнительного учета. 

В \emph{массиве} допускается замена элементов, но его \emph{\color{red}размер менять нельзя}.

Описание типа массива имеет следующий вид: \verb|[T; n]|, где \texttt{T} -- тип элемента, а \texttt{n} -- неотрицательное целое число. Например, запись \verb|[f32; 12]| обозначает массив из двенадцати 32-разрядных чисел с плавающей точкой. 

Особое внимание в Rust уделяется вопросам безопасности. При этом ведется проверка границ индексации массива. Запрос элемента, выходящего за границы, приводит к сбою (к панике в терминологии Rust), а не к возврату неверных данных.

\subsubsection{Слайсы}

Слайсы представляют собой похожие на массив объекты с динамическим размером. Понятие <<динамический размер>> означает, что их размер на момент компиляции \emph{неизвестен}. Но, как и массивы, они не могут расширяться или сокращаться.

Недостаток сведений к моменту компиляции объясняет различие в сигнатуре типа между массивом (\verb|[T;n]|) и слайсом (\verb|[T]|).

Важность слайсов объясняется тем, что реализовать типаже дли них проще, чем для массивов. Поскольку \verb|[T; 1]|, \verb|[T; 2]|, ..., \verb|[T; n]| бывают разных типов, реализация типажей для массивов может стать слишком громоздской. А создание \emph{слайса} из массива дается легко и обходится дешево, поскольку \emph{слайс не нужно привязывать к какому-либо конкретному размеру}.

Слайсы способны действовать как \emph{представление массивов} (и других слайсов). Термин <<представление>> здесь взят из описания технологии работы с базами данных и означает, что слайсы могут получать быстрый доступ только по чтению данных, что исключает необходимость копирования чего бы то ни было.

\subsubsection{Векторы}

Векторы (\verb|Vec<T>|) -- это наращиваемые списки, состоящие из обобщенных типов \texttt{T}. При выполнении программы на них тратится немного больше времени, чем на массивы, из-за дополнительного учета, необходимого для последующего изменения их размера. Но эти издержки на работу с векторами почти всегда компенсируются их дополнительной гибкостью. 

\verb|Vec<T>| эффективнее всего работает при возможности указания размера с помощью функции \verb|Vec::with_capacity()|. Предоставление этого показателя сводит к минимуму необходимое количество выделенной памяти операционной системой.

\subsection{Чтение данных из файлов}

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use std::fs::File;
use std::io::BufReader;
use std::io::prelude;

fn main() {
    let f = File::open("readme.md").unwrap();
    let reader = BufReader::new(f);
    
    for line_ in reader.lines() {
        let line = line_.unwrap();
        println!("{} ({} bytes long)", line, line.len());
    }
}
\end{lstlisting}

На Python было бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def main():
    with open("readme.md", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            print(f"{line} ({len(line)} bytes long)")
\end{lstlisting}

\section{Составные типы данных}

Чтобы помешать компилятору выдавать предупреждения, в них будут задействованы атрибуты \verb|#![Allow(unused_variables)]|.

Тип, известный как \emph{unit} \verb|()|, формально считается \emph{кортежем нулевой длины}. Он используется для выражения того, что \emph{функция не возвращает никакого значения}.

Функции, которые не имеют возвращаемого типа, возвращают \verb|()|, и выражения, заканчивающиеся точкой с запятой \verb|;|, также возвращают \verb|()|. Например, функция \texttt{report()} в следующем блоке кода подразумеваемо возвращает тип \emph{unit}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use std::fmt::Debug;

fn report<T: Debug>(item: T) { // item может быть любого типа с реализацией std::fmt::Debug
    println!("{:?}", item);
}
\end{lstlisting}

А в этом примере возвращение типа unit задается в явном виде
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn clear(text: &mut String) -> () {
    *text = String::from(""); // замена строкового значения, на которое указывает text, пустой строкой
}
\end{lstlisting}

В Python затереть значение переменной в глобальной области видимости можно было бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
>>> text = "global"
>>> def clear():
      global text  # просто расширяем область видимости функции
      text = ""  # привязываем переменную text к пустой строке
>>> text  # 'global'
>>> clear()
>>> text  # '' 
\end{lstlisting}

Последнее выражение в функции не должно заканчиваться точкой с запятой. \emph{Восклицательный знак} \verb|!|, известен как тип <<Never>>. \verb|Never| показывает, что \emph{функция никогда ничего не возвращает}, особенно при гарантированном сбое.

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn dead_end() -> ! { // функция никогда ничего не возвращает
    panic!("you have reached a dead end");
}
\end{lstlisting}

Макрос \verb|panic!| вызывает сбой программы. То есть функция \emph{гарантировано никогда не вернет управление} вызвавшему ее коду.

Структура \texttt{struct} позволяет создавать составной тип, образованный из других типов. Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct File {
    name: String,
    data: Vec<u8>,
}
\end{lstlisting}

Чтобы позволить структуре \texttt{File} стать выводимой на экран строкой, нужно поместить строку \verb|#[derive(Debug)]| перед определением структуры

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#[derive(Debug)]  // чтобы можно было вывести на печать структуру
struct File {
	name: String,
	data: Vec<u8>,
}
\end{lstlisting}

При определении структуры можно явно указывать время жизни каждого поля. Явное указание времени жизни требуется, когда поле является ссылкой на другой объект.

Экземпляр структуры можно создать так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn main() {
    let f1 = File { // экземпляр структуры
        name: String::from("f1.txt"),
        data: Vec::new(),
    };

    let f1_name = &f1.name;
    let f1_length = &f1.data.len();
    
    println!("{:?}", f1);
}
\end{lstlisting}

К началу имени добавляется амперсанд (\verb|&f1.name|), свидетельствующий о желании получить \emph{доступ к данным по ссылке}. На языке Rust это означает, что переменные \verb|f1_name| и \verb|f1_length| \emph{заимствуют} данные, на которые они ссылаются.

\subsection{Добавление метдов к структуре struct путем использования блока impl}

В Rust классы, так сказать, распадаются на структуры \texttt{struct} и реализации \texttt{impl}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct File {
    // data
}

impl File {
    // methods
}
\end{lstlisting}

Rust отличается от других языков, поддерживающих методы: в нем нет ключевого слова \texttt{class}. Типы, созданные с помощью блока \texttt{struct}, иногда кажутся классами, но поскольку они \emph{не поддерживают наследование}, то хорошо, что их называли по-другому.

Для определения методов Rust-программистами используется блок \texttt{impl}.

Создание объектов с уместными значениями по умолчанию выполняется с помощью метода \texttt{new()}. Каждую структуру можно создать, воспользовавшись литеральным синтаксисом, но это приводит к ненужной многословности.

Использование \texttt{new()} -- соглашение, принятое в сообществе Rust. В отличие от других языков, \texttt{new} не является ключевым словом и не имеет какого-либо особого статуса по сравнению с другими методами
\begin{lstlisting}[
title = {Использование блока impl для добавления методов к структуре},
style = c_cpp,
numbers = none
]
#[derive(Debug)]
struct File {
    name: String,
    data: Vec<u8>,
}

impl File {
    fn new(name: &str) -> File {
        File {
            name: String::from(name),
            data: Vec::new(),
        }
    }
}

fn main() {
    let f3 = File::new("f3.txt");
    
    let f3_name = &f3.name;
    let f3_length = f3.data.len();
    
    println!("{:?}", f3);
    println!("{} is {} bytes long", f3_name, f3_length);
}
\end{lstlisting}

В Rust небезопасность означает <<тот же уровень безопасности, который всегда обеспечивается языком С>>.

Небольшие дополнения к языку Rust:
\begin{itemize}
	\item Изменяемые глобальные переменные обозначаются с помощью \verb|static mut|,
	
	\item По соглашению в именах глобальных переменных ВСЕ БУКВЫ ЗАГЛАВНЫЕ,
	
	\item Ключевое слово \texttt{const} включается для тех значений, которые никогда не изменяются.
\end{itemize}

Опытным программистам известно, что использование глобальной переменной \texttt{errno} во время системных вызовов обычно регулируется операционной системой. Как правило, в Rust такой стиль программирования не приветствуется, поскольку при нем не только нарушается безопасность типов (ошибки кодируются в виде простых целых чисел), но и в <<награду>> неравдивым программистам, забывающим проверить значение переменной \texttt{errno}, может проявиться нестабильность программ.

\paragraph{Разница между \texttt{const} и \texttt{let}} Данные, определяемые с \texttt{let}, могут изменяться. Rust позволяет типам обладать явно противоречивым свойством \emph{внутренней изменчивости}.

Некоторые типы, например \verb|std::sync::Arc| и \verb|std::rc::Rc|, представляют собой неизменяемый фасад, но по прошествии времени изменяют свое внутренее состояние. По мере того, как на них делаются ссылки, они увеличивают значение счетчика ссылок и уменьшают его значение, когда срок действия этих ссылок истекает.

На уровне компилятора \texttt{let} больше относится к использованию псевдонимов, чем к неизменяемости. Использование псевдонимов в понятиях компилятора означает одновременное наличие нескольких ссылок на одно и то же место в памяти.

Ссылки на переменные, доступные только для чтения (их заимствования), объявленные с помощью \texttt{let}, могут указывать на одни и те же данные. Ссылки для чтения-записи (изменяемые заимствования) гарантированно никогда не станут псевдонимами данных.

\subsection{Использование возвращаемого типа Result}

Подход, принятый в Rust к обработке ошибок, заключается в использовании типа, который соответствует как стандартному случаю, так и случаю ошбики. Этот тип известен как \texttt{Result}. У него два состояния: \texttt{Ok} и \texttt{Err}.

Для вызова функций, возвращающих \texttt{Result<File, String>}, требуется дополнительный метод \verb|unwrap()|, позволяющий извлечь значение. Вызов \verb|unwrap()| снимает оболочку с \verb|Ok(File)| для создания \verb|File|. При обнаружении ошибки \verb|Err(String)| прогрмма даст сбой.

\texttt{Result} -- перечисление \texttt{enum}. Перечисление \texttt{enum} -- это тип, способный представлять несколько известных вариантов, например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum Suit {
    Clubs,
    Spades,
    Diamonds,
    Hearts,
}

enum Card {
    King(Suit),
    Queen(Suit),
    Jack(Suit),
    Ace(Suit),
    Pip(Suit, usize),
}
\end{lstlisting}

Как и структуры, \emph{перечисления} поддерживают \emph{методы} через блоки \texttt{impl}. Перечисления в Rust эффективнее набора констант.

Определение основных характеристик типажа Read для File
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#![allow(unused_variables)]

// структура 
#[derive(Debug)]
struct File;

// типаж для структуры File, задающий протокол
trait Read {
	fn read( // этот метод должен быть реализован в блоке impl
		self: &Self, // пседотип
		save_to: &Vec<u8>,
	) -> Result<usize, String>;
}

// имплементация
impl Read for File {
	fn read(
		self: &File,
		save_to: &Vec<u8>,
	) -> Result<usize, String> {
		Ok(0)
	}
}

fn main() {
	let f = File{};
	let mut buffer = vec![];
	let n_bytes = f.read(&mut buffer).unwrap();
	
	println!("{} byte(s) read from {:?}", n_bytes, f);
}
\end{lstlisting}

\texttt{Display} требует, чтобы в типах был реализован метод \texttt{fmt}, возвращающий \texttt{fmt::Result}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// типаж (протокол/контракт/интерфейс) Display требует,
// чтобы в типе был реализован метод fmt
impl Display for FileState {
    fn fmt(
        &self,
        f: &mut fmt::Formatter,
    ) -> fmt::Result {
        match *self {
            FileState::Open => write!(f, "OPEN"),
            FileState::Closed => write!(f, "CLOSED"),
        }
    }
}

// типаж (протокол/контракт/интерфейс) Display требует,
// чтобы в типе был реализован метод fmt
impl Display for File {
    fn fmt(
        &self,
        f: &mut fmt::Formatter,
    ) -> fmt::Result {
        write!(f, "<{} ({})>", self.name, self.state)
    }
}
\end{lstlisting}

Rust'ие перечисления напоминают Python'ие именованные кортежи
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# Rust
# enum FileState {
#    Open,
#    Closed
# }
from collection import namedtuple

attrs = ("open", "closed")
FileState = namedtuple("FileState", attrs)(*attrs)
FileState.open # 'open'
FileState.closed # 'closed'
\end{lstlisting}

Для сборки документации проекта без зависимостей
\begin{lstlisting}[
style = bash,
numbers = none
]
$ cargo doc --no-deps --open
\end{lstlisting}

Группа символов \verb|///| приводит к созданию документов, ссылающихся на элемент, который следует непосредственно за ней
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
/// Represents a "file",
/// which probaly lives on a file system.
#[derive(Debug)]
pub struct File {
    name: String,
    data: Vec<u8>,
}

impl File {
    /// New files are assumed to be empty, but a name is required.
    pub fn new(name: &str) -> File {
         File {
             name: String::from(name),
             data: Vec::new(),
         }
    }
}
\end{lstlisting}

Можно приемы форматирования текста на Markdown
\begin{lstlisting}[
numbers = none
]
...
impl File {
    /// Creates a new, empty `File`.
    ///
    /// #*Examples*
    /// ```
    /// let f = File::new("f1.txt");
    /// ```
    pub fn new(name: &str) -> File {
        File {
            name: String::from(name),
            data: Vec::new(),
        }
    }
}
\end{lstlisting}

Строки, начинающиеся с \verb|///| попадут в документацию. То есть это что-то вроде Python'их doc-strings.

С группы символов \verb|//!| начинается описание проекта.

\section{Время жизни, владение и заимствование}

\emph{Контроллер заимствований} (borrow checker) -- проверяет \emph{законность} любого \emph{доступа к данным}, что позволяет Rust избежать проблем с безопасностью.

Проверка заимствований основана на трех взаимосвязанных понятиях:
\begin{enumerate}
	\item Время жизни,
	
	\item Владение,
	
	\item Заимствование.
\end{enumerate}

\emph{Владение} в Rust связано \emph{с избавлением от значений}, в которых больше нет надобности. Например, функция возвращает управление, необходимо освободить память, содержащую ее локальные переменные.

\emph{Время жизни значения} -- это период, в течение которого доступ к этому значению -- допустимое поведение. Локальные переменные функции живут до тех пор, пока функция не вернет управление, а глобальные переменные могут жить в течение всего времени жизни программы.

\emph{Позаимствовать} значение означает \emph{получить к нему доступ}. Суть этого термина призвана подчеркнуть возможность общего доступа к значениям из многих частей программы при наличии у них одного владельца.

Термин \emph{перемещение} (move) в Rust  означает нечто специфическое. Движение внутри кода Rust относится к \emph{переходу владения}, а не к перемещению данных. 

\emph{Владение} -- это понятие, используемое в сообществе Rust для обозначения процесса времени компиляции, который проверяет, что каждое использование значения допустимо и что каждое значение полностью уничтожено. Каждое значение внутри Rust -- это владение.

Попытка перезаписи значения, которое все еще доступно в другом месте программы, приводит к тому, что компилятор отказывается компилировать программу.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn main() {
	// Владение возникает здесь при создании объекта CubeSat
    let sat_a = CubeSat { id: 0 };
    // ...
    // Владение объектом переходит к check_status(), но не возвращается к main()
    let a_status = check_status(sat_a);
    // ...
    // sat_a больше не владелец объекта, что делает доступ недействительным
    let a_status = check_status(sat_a);
}
\end{lstlisting}

В ходе вызова \verb|check_status(sat_a)| владение переходит к функции \verb|check_status()|. Когда \verb|check_status()| возвращает сообщение, она удаляет значение \verb|sat_a|. Здесь время жизни \verb|sat_a| заканчивается. И все же после первого вызова \verb|check_status()| переменная \verb|sat_a| остается в локальной области видимости функции \verb|main()|. Попытка получения доступа к этой переменной вызовет возмущение контролера зависимостей.

В Rust у \emph{элементарных типов} особое поведение. В них реализован типаж \verb|Copy|. {\color{blue}Формально \emph{элементарные типы} обладают \emph{семантикой копирования}, а все другие типы имеют \emph{семантику перемещения}.}

{\color{red}При использовании значений в качестве аргумента той функции, которая становится их владельцем, получить к этим значениям новый доступ из внешней области видимости уже невозможно.}

\begin{lstlisting}[
title = {\sffamily \emph{Семантика копирования} элементарных типов Rust},
style = c_cpp,
numbers = none
]
fn use_value(_val: i32) {}

fn main() {
    let a = 123;
    use_value(a);
    
    println!("{}", a);  // + получение доступа к `a` после вызова use_value() вполне нормально
}
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily \emph{Семантика перемещения} для типов, не реализующих Copy},
style = c_cpp,
numbers = none
]
fn use_value(_val: Demo) {}

struct Demo {
    a: i32,
}

fn main() {
    let demo = Demo {a: 123};
    use_value(demo);
    
    println!("{}", demo.a);  // - доступ к demo.a невозможен даже после возвращения из use_value()
}
\end{lstlisting}

В Rust \emph{передача владения} от одной переменной к другой осуществляется двумя способами:
\begin{enumerate}
	\item по привязке переменной
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn main() {
    let sat_a = CubeSat { id: 0 }; // передача владения по привязке переменной
}
\end{lstlisting}
	
	\item через функциональный барьер либо в качестве аргумента, либо в качестве возвращаемого значения
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
fn main() {
    let sat_a = CubeSat { id: 0 };
    // ...
    let new_sat_a = check_status(sat_a); // передача владения через функциональный барьер
    // ...
}
\end{lstlisting}
\end{enumerate}

\subsection{Решение проблем, связанных с владением}

Изюминка Rust -- система владения. Ею обеспечивается безопасность памяти без использования сборщика мусора.

\subsubsection{Если полное владение не требуется, используйте ссылки}

Чаще всего в код вносится уменьшение необходимого уровня доступа. Вместо запроса владения в определениях функций можно воспользоваться <<заимствованием>>.

Для доступа \emph{только по чтению} следует использовать \verb|&T|, а для доступа \emph{по чтению-записи} -- \verb|&mut T|.

\begin{lstlisting}[
title = {\sffamily Использование владения},
style = c_cpp,
numbers = none
]
fn send(to: CubeSat, msg: Message) {
    to.mailbox.messages.push(msg); // владение значением переменной to переходит функции send
}
\end{lstlisting}

Владение значением переменной \texttt{to} переходит к функции \texttt{send()}. При возвращении из \texttt{send()} значение переменной \texttt{to} \emph{удаляется}.

\begin{lstlisting}[
title = {\sffamily Использование \emph{ссылки} на изменяемое значение},
style = c_cpp,
numbers = none
]
fn send(to: &mut CubeSat, msg: Message) {
    to.mailbox.messages.push(msg);
}
\end{lstlisting}

Добавление префикса \verb|&mut| к типу \texttt{CubeSat} позволяет \emph{внешней области видимости сохранять владение данными}, на которые \emph{указывает} переменная \texttt{to}.

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
impl GrounStation {
    fn send(
        &self,
        to: &mut CubeSat,
        msg: Message,
    ) {
        to.mailbox.messages.push(msg);
    }
}

impl CubeSat {
    fn recv(&mut self) -> Option<Message> {
        self.mailbox.messages.pop()
    }
}
\end{lstlisting}

Здесь \verb|&self| указывает, что \verb|GroundStation.send()| требуется ссылка на \verb|self| \emph{с доступом только на чтение}. Получатель берет \emph{изменяемое заимствование} (\verb|&mut|) экземпляра \verb|CubeSat|, а \verb|msg| становится полноправным владельцем его экземпляра \verb|Message|.

Владение экземпялром сообщения \verb|Message| переходит от \verb|msg| к локальной переменной функции \verb|message.push()|.

\subsubsection{Сократите количество долгоживующих значений}

Если есть крупный долгоживующий объект, например глобальная переменная, то хранить его для каждого компонента программы, который в нем нуждается, весьма неудобно.

Вместо использования долгоживующих объектов стоит подумать о создании недолговечных отдельных объектов. Иногда проблемы, связанные с владением, можно решить за счет пересмотра конструкций всей программы.

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
impl GroundStation {
    fn send(
        &self,
        mailbox: &mut Mailbox,
        to: &CubeSat,
        msg: Message,
    ) {
        mailbox.post(to, msg);
    }
}

impl CubeSat {
    fn recv(
        &self,
        mailbox: &mut Mailbox,
    ) -> Option<Message> {
        mailbox.deliver(&self)
    }
}

impl Mailbox {
    fn post(
        &mut self,  // изменяемый доступ к самому себе
        msg: Message  // владение сообщением
    ) {
        self.message.push(msg);
    }

    fn deliver(
        &mut self,
        recipient: &CubeSat
    ) -> Option<Message> {
        for i in 0..self.message.len() {
            if self.messages[i].to == recipient.id {
                let msg = self.messages.remove(i);
                return Some(msg);
            }
        }
        None
    }
}
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily Реализации стратегии недолговечных переменных},
style = c_cpp,
numbers = none
]
#![allow(unused_variables)]

#[derive(Debug)]
struct CubeSat {
    id: u64
}

#[derive(Debug)]
struct Mailbox {
    messages: Vec<Message>,
}

#[derive(Debug)]
struct Message {
    to: u64,
    content: String,
}

struct GroundStation {}

impl Mailbox {
    fn post(
        &mut self,  // метод будет изменять экземпляр Mailbox
        msg: Message
    ) {
        self.messages.push(msg);
    }

    fn deliver(
        &mut self,  // метод будет изменят экземпляр Mailbox
        recipient: &CubeSat
    ) -> Option<Message> {
        for i in 0..self.messages.len() {
            if self.messages[i].to == recipient.to {
                let msg = self.messages.remove(i);
                return Some(msg);
            }
        }
        None
    }
}

impl GroundStation {
    fn connect(&self, sat_id: u64) -> CubeSat {
        CubeSat {
            id: sat_id,
        }
    }

    fn send(
        &self, // доступ на чтение GroundStation
        mailbox: &mut Mailbox,  // экземпляр Mailbox будет изменяться
        msg: Message
    ) {
        mailbox.post(msg);
    }
}

impl CubeSat {
    fn recv(
        &self,  // доступ только на чтение CubeSat
        mailbox: &mut Mailbox  // экземпляр Mailbox будет изменяться
    ) -> Option<Message> {
        mailbox.deliver(&self)
    }
}

fn fetch_sat_ids() -> Vec<u64> {
    vec![1, 2, 3]
}

fn main() {
    let mut mail = Mailbox { messages: vec![] };
    
    let base = GroundStation {};
    
    let sat_ids = fetch_sat_ids();
    
    for sat_id in sat_ids {
        let sat = base.connect(sat_id);
        let msg = Message { to: sat_id, content: String::from("hellow")};
        base.send(&mut mail, msg);
    }

    let sat_ids = fetch_sat_ids();
    
    for sat_id in sat_ids {
        let sat = base.connect(sat_id);
        
        let msg = sat.recv(&mut mail);
        println!("{:?}: {:?}", sat, msg);
    }
}
\end{lstlisting}

На Python код выглядел бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import typing as t
from dataclasses import dataclass, field

# В поисках типов код просматривается сверху вниз, поэтому
# приходится вводить служебные типы
_CubeSat = t.NewType("_CubeSat", type)
_Mailbox = t.NewType("_Mailbox", type)

# В Rust это `struct Message`
class Message(t.NamedTuple):
	to: int  # поле
	content: str  # поле

# В Rust это `struct Mailbox` и `impl Mailbox`
@dataclass(frozen=False)
class Mailbox:
	# В Rust это блок struct
	messages: t.List[_Message] = field(default_factory=list)  # NB!

	# В Rust это блок impl
	def post(self, msg: _Message) -> t.NoReturn:
		# Доступ к полю messages экземпляра через self
		self.messages.append(msg)  # эта инструкция изменяет экземпляр дата-класса

	def delivier(self, recipient: _CubeSat) -> t.Optional[Message]:
		for i in range(len(self.messages)):
			if self.messages[i].to == recipient.id:
				msg = self.messages.pop(i)  # эта инстукция изменяет экземпляр дата-класса
				return msg

		return None

# В Rust это `struct CubeSat` и `impl CubeSat`
@dataclass(frozen=False)
class CubeSat:
	id: int  # поле

	def recv(self, mailbox: _Mailbox) -> t.Optional[Message]:
		return mailbox.delivier(self)

def fetch_sat_ids() -> t.List[int]:
	return [1, 2, 3]

# В Rust это `struct GroundStation` и `impl GroundStation`
@dataclass(frozen=False)
class GroundStation:
	# В Rust это блок impl
	def connect(self, sat_id: int) -> CubeSat:
		return CubeSat(id=sat_id)

	def send(self, mailbox: _Mailbox, msg: Message):
		return mailbox.post(msg)


def main():
	mail = Mailbox()
	base = GroundStation()
	sat_ids = fetch_sat_ids()

	for sat_id in sat_ids:
		sat = base.connect(sat_id)
		msg = Message(to=sat_id, content="hello")
		base.send(mail, msg)

	sat_ids = fetch_sat_ids()
	for sat_id in sat_ids:
		sat = base.connect(sat_id)
		msg = sat.recv(mail)
		print(f"{sat}: {msg}")


if __name__ == "__main__":
	main()
\end{lstlisting}

Экземпляр сообщения \texttt{Message} не изменяется после создания, поэтому его можно представить простым именованным кортежем, а не дата-классом. \texttt{Mailbox} приходится представлять дата-классом, потому что поле \texttt{messages} изменяемое. Причем это поле нужно создавать обязательно как \verb|default_factory=list|, чтобы безопасно инициализировать поле экзмепляра пустым списком
\begin{lstlisting}[
style = ironpython,
numbers = none
]
messages: t.List[Message] = field(default_factory=list)
\end{lstlisting}

\subsubsection{Продублируйте значение}

Наличие одного владельца для каждого объекта может свидетельствовать о серьезной предварительной проработке замысла.

Одной из самых простых альтернатив реструктуризации может стать простое копирование значения. Зачастую копирование не приветствуется, но в крайнем случае оно может оказаться полезным. Хорошим примером могут послужить элементарные типы, такие как целые числа. Их дублирование обходится центральному процессору настолько дешево, что Rust-компилятор, чтобы не заниматься переходом владения, всегда именно так и делает.

Типы могут выбрать один из двух режимов дублирования:
\begin{itemize}
	\item клонирование \verb|std::clone::Clone|,
	
	\item копирование \verb|std::marker::Copy|.
\end{itemize}

У каждого режима имеется свой типаж. Копирование выполняется подразумеваемым образом. Если владение переходит во внутреннюю область видимости, то значение просто дублируется. Клонирование выполняется явным образом.

\emph{Клонирование} (\verb|std::clone::Clone|):
\begin{itemize}
	\item Может быть медленным и затратным,
	
	\item Никогда не бывает подразумеваемым. Всегда требует вызова метода \verb|.clone()|,
	
	\item Могут быть отличия от оригинала. Что именно означают клонирования, для их типов определяется автором контейнера.
\end{itemize}

\emph{Копирование} (\verb|std::marker::Copy|):
\begin{itemize}
	\item Всегда бывает быстрым и дешевым,
	
	\item Всегда бывает подразумеваемым,
	
	\item Всегда создает идентичную копию. Копии являются побитными дубликатами оригинального значения.
\end{itemize}

Но иногда стоит отдать предпочтнеие клонированию:
\begin{enumerate}
	\item Предполагается, что типаж \texttt{Copy} практически не снижает производительность. С числами -- да, но только не с типами произвольных размеров, такими как \texttt{String},
	
	\item Поскольку \texttt{Copy} создает абсолютно точные копии, он не способен корректно интерпретировать ссылки. Простое копирование ссылки на \texttt{T} приведет к попытке создания второго владельца \texttt{T}. Впоследствии будут проблемы с несколькими попытками удаления \texttt{T} по мере удаления каждой ссылки,
	
	\item Некоторые типы перегружают типаж \texttt{Clone} с целью предоставления чего-то похожего, но отличного от создания дубликатов.
\end{enumerate}

При работе с Rust типажи \verb|std::clone::Clone| и \verb|std::marker::Copy| фигурируют обычно просто как \verb|Clone| и \verb|Copy|. Они включены в область видимости каджого контейнера через стандартную прелюдию.

\section{Углубленное изучение данных}

Инструмент \texttt{unsafe} сообщает компилятору Rust следующее: <<Не трогай, я сам обо всем позабочусь. Все под контролем>>. Это сигнал компилятору, что специфика кода выходит за рамки проверки корректности программы.

Использование ключевого слова \texttt{unsafe} не означает, что код по своей сути опасен. К примеру, его указание не позволяет обойти выполняемую в Rust проверку заимствований. Это означает, что компилятор не может автоматически гарантировать безопасность памяти программы. Использование \texttt{unsafe} означает, что ответственность за целостность программы полностью возлагается на программиста.

Использование блоков \texttt{unsafe} без крайеней нужды воспринимается Rust-сообществом весьма неодобрительно. Безопасность программы может быть поставлена под удар за счет появления в ней серьезных уязвимостей.

{
\color{blue}
Основная цель использования таких блоков -- позволить программе на языке Rust взаимодействовать с внешним кодом, например с библиотеками, написанными на других языках, и с интерфейсом операционной системы.
}

16-разрядное целое число может представлять числа от 0 до 65 535 включительно. А что произойдет, если нужно будет сосчитать до 65 536?

Технический термин для класса исследуемой проблемы -- \emph{целочисленное переполнение}. Одним из самых безвредных способов переполнения целого числа является бесконечное увеличение.

Запаниковашая программа -- мертвая программа. Паника означает, что программист попросил сделать что-то невозможное. Она не знает, что нужно сделать, чтобы продолжить выполнение, и отключается.

Программисты с опытом работы исключительно с динамическими языками программирования вряд ли когда-либо столкнуться с целочисленным переполнением.

\emph{Динамические языки} обычно проверяют, умещаются ли результаты целочисленных выражений в используемый диапазон. Если нет, то переменная, получающая результат, \emph{переводится в более широкий целочисленный тип}.

Некоторые процессоры упорядочивают многобайтовые последовательности слева направо, а другие -- справа налево. Эта особенность известна как присущий центральному процессору порядок следования байтов. В ней кроется одна из причин, по которой копирование исполняемого файла с одного компьютера на другой может привести его в нерабочее состояние.

Блок \verb|impl From<T> for U| предписывает языку Rust порядок преобразования типа \verb|T| в тип \verb|U|. При этом требуется, чтобы в типе \verb|U| была реализована функция \verb|from()|, принимающая в качестве своего единственного аргумента значение типа \verb|T|. Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
impl From<f64> for Q7 {
    fn from(n: f64) -> Self {
        if n >= 1.0 {
            Q7(127)
        } else if n <= -1.0 {
            Q7(-128)
        } else {
            Q7((n * 128.0) as i8)
        }
    }
}
\end{lstlisting}

Для модульного тестирования используется инструментальное средство \verb|cargo test|. Реализация формата \verb|Q7|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Q7(i8);

impl From<f64> for Q7 { // f64 -> Q7
    fn from(n: f64) -> Self {
        if n >= 1.0 {
            Q7(127)
        } else if n <= -1.0 {
            Q7(-128)
        } else {
            Q7((n * 128.0) as i8)
        }
    }
}

impl From<Q7> for f64 {  // Q7 -> f64
    fn from(n: Q7) -> f64 {
        (n.0 as f64) * 2_f64.powf(-7.0)
    }
}

impl From<f32> for Q7 {  // f32 -> Q7
    fn from(n: f32) -> Self {
        Q7::from(n as f64)
    }
}

impl From<Q7> for f32 {  // Q7 -> f32
    fn from(n: Q7) -> f32 {
        f64::from(n) as f32
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn out_of_bounds() {
        assert_eq!(Q7::from(10.0), Q7::from(1.0));
        assert_eq!(Q7::from(-10.0), Q7::from(-1.0));
    }

    #[test]
    fn f32_to_q7() {
        let n1: f32 = 0.7;
        let q1 = Q7::from(n1);
        
        let n2 = -0.4;
        let q2 = Q7::from(n1);
        
        let n3 = 123.0;
        let q3 = Q7::from(n3);
        
        assert_eq!(q1, Q7(89));
        assert_eq!(q2, Q7(-51));
        assert!eq!(q3, Q7(127));
    }

    #[test]
    fn q7_to_f32() {
        let q1 = Q7::from(0.7);
        let n1 = f32::from(q1);
        assert_eq!(n1, 0.6953125);
        
        let q2 = Q7::from(n1);
        let n2 = f32::from(q2);
        assert_eq!(n1, n2);
    }
}
\end{lstlisting}

\subsection{Краткий обзор модульной системы в Rust}

Модульная симстема основана на следующих положениях:
\begin{itemize}
	\item Модули объединяются в контейнеры.
	
	\item Модули могут быть определены структурой каталогов проекта. Если каталог \verb|src/| содержит файл \verb|mod.rs|, то его подкаталоги становятся модулями.
	
	\item Модули также могут определены в файле с помощью ключевого слова \verb|mod|.
	
	\item Модули могут иметь произвольные вложения.
	
	\item Все элементы модуля, включая его подмодули, по умолчанию \emph{закрытые}. Досуп к закрытым элементам можно получить как в самом модуле, так и в любых его потомках.
	
	\item К тому, что нужно сделать доступным, следует добавить в качестве префикса ключевое слово \verb|pub|. У этого ключевого слова имеется ряд особенностей:
	\begin{itemize}
		\item \verb|pub(crate)| предосталяет доступ к элементу другим модулями внутри контейнера (крейта).
		
		\item \verb|pub(super)| предоставляет доступ к элементу со стороны родительского модуля.
		
		\item \verb|pub(in path)| предоставляет доступ к элементу в пределах указанного пути.
		
		\item \verb|pub(self)| явным образом сохраняет открытый доступ к элементу в его модуле.
		\end{itemize}
	
	\item Элементы из других модулей переносятся в локальную область видимости с помощью ключевого слова \verb|use|.
\end{itemize}

\subsection{Память}

\subsubsection{Указатели}

Указатели -- это просто числа, ссылающиеся на что-либо иное. Внутри компьютера \emph{указатели} кодируются в виде \emph{целого числа} (эквивалентного \verb|usize|), являющегося \emph{адресом памяти} объекта ссылки (данных, на которые ссылается указатель).

В Rust указатели чаще всего встречаются в виде \verb|&T| и \verb|&mut T|, где \verb|T| -- это тип.

\emph{Адреса памяти} -- абстракции, предоставляемые языками Ассемблера. Указатель представляет собой адрес памяти, указывающий на значение какого-либо типа. Указатели, по сути, -- абстракции, предоставляемые языками более более высокого уровня. Ссылки -- абстракции, предоставляемые языком Rust.

У Rust-ссылок имеются существенные преимущества перед указателями:
\begin{itemize}
	\item {\color{blue}Ссылки всегда указыают на реально существующие данные}. 
	
	\item Ссылки корректно выравнены по кратным \verb|usize|. По техническим причинам центральные процессоры крайне негативно реагируют на требование извлечь данные без выравнивания памяти. В типы Rust включаются байты заполнения, чтобы создание ссылок на них не замедляло работу программ.
	
	\item Ссылки гарантируют производительную работу с типами, имеющими динамически изменяемый размер.
\end{itemize}

\subsubsection{Обычные указатели, используемые в Rust}

\emph{Обычный указатель} -- адрес памяти. Стандартные гарантии Rust на него не распространяются, что делает его небезопасным. Например, в отличие от ссылок (\verb|&T|), обычные указатели могут иметь значение \verb|null|.

\emph{Обычные неизменяемые указатели} станем обозначать как \verb|*const T|, а \emph{изменяемые} -- как \verb|*mut T|. Их тип \verb|T| в качестве обычного указателя на \verb|String| выглядит как \verb|*const String|. Обычный указатель на \verb|i32| выглядит как \verb|*mut i32|.

Важно:
\begin{itemize}
	\item {\color{blue}Разница между \verb|a *mut T| и \verb|a *const T| минимальна}. Они могут свободно приводится друг к другу и, как правило, обладают взаимозаменяемостью, действуя в исходном коде в качестве документации.
	
	\item {\color{blue}Rust-ссылки (\verb|&mut T| и \verb|&T|) \emph{при компиляции} превращаются в \emph{обычные указатели}}. То есть для достижения высокой производительности, присущей обычным указателям, можно вполне обойтись и без риска использования небезопасных \verb|unsafe|-блоков.
\end{itemize}

Пример приведения \emph{ссылки на переменную} (\verb|&a|) к \emph{неизменяемому обычному указателю} (\verb|*const i64|)
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn main() {
    let a: i64 = 42;
    let a_ptr = &a as *const i64;
    
    println!("a={} ({:p})", a, a_ptr);
}
\end{lstlisting}

Иногда термины <<указатель>> и <<адрес памяти>> используются как синонимы. Это целые числа, представляющие собой место в виртуальной памяти. Но с позиции компилятора имеется одно важное отличие. Типы \emph{Rust-указателей} \verb|*const T| и \verb|*mut T| \emph{всегда нацелены на начальный байт} \verb|T|, и им также известна ширина типа \verb|T| в байтах. А \emph{адрес памяти} может относится к любому месту в памяти.

Тип \verb|i64| имеет ширину 8 байт (64 бита при 8 битах на байт). Следовательно, если \verb|i64| храниться по адресу \verb|0x7fffd|, то для воссоздания целочисленного значения из оперативной памяти должет быть извлечен каждый из байтов диапазона \verb|0x7ffd...0x8004|. Процесс выборки данных \emph{из оперативной памяти} называется \emph{разыменованием указателя}.

Закулисно \emph{ссылки} (\verb|&T| и \verb|&mut T|) реализуются в виде простых указателей. Им сопутствуют дополнительные гарантии, и предпочтение следует неизменно отдавать только им.

{\color{red} \emph{\underline{Обычные указатели}} небезопасны!!!} Им присущи некоторые свойства, определющие крайнюю нежелательность их повседневного использования в Rust-коде:
\begin{itemize}
	\item {\color{red}Обычные указатели не владельцы своих значений}. При обращении к ним \emph{компилятор не проверяет доступность данных}, на которые они указывают.
	
	\item {\color{red}Допускается использование нескольких обычных указателей на одни и те же данные}. Каждый обычный указатель может иметь доступ к записи или к чтению и записи данных. Это означает, что Rust не может гарантировать действительность совместно используемых данных.
\end{itemize}

Обычные указатели небезопасны. Альтернативой может послужить использование \emph{интеллектуальных указателей}. Как правило, типы интеллектуальных указателей Rust служат оболочкой для обычных указателей и наделяют их дополнительной семантикой.

\subsubsection{Предоставление программам памяти для размещения их данных}

{\color{blue}\emph{Стек} работает быстро, а \emph{куча} -- медленно.}

\paragraph{Стек}

С записями в стеке обращаются по принципу <<последней пришла -- первой ушла>> (LIFO). Записи называются \emph{кадрами стека}. Они создаются по мере выполнения вызовов функций.

В отличие от обеденных тарелок, каждый кадр стека имеет разный размер. В нем имеется пространство для аргументов его функции, указатель на исходное место вызова и значения локальных переменных (за исключением тех данных, что размещены в куче). 

Основная роль стека -- предоставить место для локальных переменных. Все переменные функции находятся в памяти рядом друг с другом. Это ускоряет доступ.

У \verb|&str| и \verb|String| разные представления в памяти: \verb|&str| память выделяется в стеке, а \verb|String| -- в куче.

В тех случаях, когда требуется \emph{доступ только по чтению}, следует использовать функции с сигнатурой типа \verb|fn x<T: AsRef<str>>(a: T)|, а не \verb|fn x(a: String)|. Читается так: <<Будучи функцией, \verb|x| получает аргумент пароля типа \verb|T|, где в \verb|T| реализуется \verb|AsRef<str>|>>. Средства реализации \verb|AsRef<str>| ведут себя как ссылки на \verb|str|, даже если это и не соответствует действительности.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn is_strong<T: AsRef<str>>(
    password: T  // либо String, либо &str
) -> bool {
    password.as_ref().len() > 5
}
\end{lstlisting}

Когда к аргументу требуется доступ по чтению и записи, в большинстве случаев можно воспользоваться родственником \verb|AsRef<T>| типажом \verb|AsMut<T>|. 


\paragraph{Куча}

\emph{Куча} -- область программной памяти для тех \emph{типов}, \emph{размер} которых в ходе компиляции \emph{еще не известен}. Некоторые типы по мере надобности меняются в размере в обе стороны. Очевидные примеры -- \verb|String| и \verb|Vec<T>|. Есть и другие типы, неспособные сообщить Rust-компилятору, сколько памяти под них выделять, несмотря на то что их размер в ходе выполнения программы не меняется. Их называют типами с динамически определяемым размером. У слайсов на момент компиляции отсутствует длина. Слайс по сути -- указатель на какую-то часть массива. Но фактически слайсы представляют некоторое количество элементов этого массива.

С позиции пользователя главной отиличительной чертой \emph{кучи} является то, что обращение к находящимся в ней переменным должно осуществляться \emph{через указатель}, чего не требуется переменным, доступным в стеке.

Простой пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
let a: i32 = 40;  // находится в стеке
let b: Box<i32> = Box::new(60);  // находится в куче
\end{lstlisting}

Упакованное значение, присвоенное \verb|b|, доступно \emph{только через указатель}. Чтобы получить доступ к этому значению, нам нужно его \emph{разыменовать}. Унарным оператором разыменования служит символ \verb|*|, помещаемый перед именем переменной:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
...
let result = a + *b;  // разыменование указателя
println!("{} + {} = {}", a, b, result);
\end{lstlisting}

Использование синтаксиса \verb|Box::new(T)| приводит к размещению \verb|T| в \emph{куче}. Что-то, что было упаковано, размещено в \emph{куче} с \emph{указателем} на него, помещенным в \emph{стек}.

Стек и куча -- это всего лишь концептуальные \emph{абстракции}. Это \emph{не физические разделы памяти} вашего компьютера.

В \emph{стеке} скоростной доступ к данным обусловлен тем, что размещенные в нем \emph{локальные переменные функций располагаются в оперативной памяти рядом} друг с другом. Иногда это называют \emph{сплошной раскладкой}. Сплошная раскладка хорошо подходит для кеширования.

В куче значения переменных вряд ли будут располагаться рядом друг с другом. Более того, доступ к данным \emph{\color{red}в куче невозможен без разыменования указателя}.

\section{Файлы и хранилища}

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use std::fs::File;
use std::io::prelude::*;
use std::env;

const BYTES_PER_LINE: usize = 16;

fn main() {
	// ввод не проверяется!!!
    let arg1 = env::args().nth(1);
    
    let fname = arg1.expect("usage: fview FILENAME");
    
    let mut f = File::open(&fname).expect("Unable to open file");
    let mut pos = 0;
    let mut buffer = [0; BYTES_PER_LINE];
    
    while let Ok(_) = f.read_exact(&mut buffer) {  // f --data--> buffer
        print!("[0x{:08x}] ", pos);
        for byte in &buffer {
            match *byte {
                0x00 => print!(". "),
                0xff => print!("## "),
                _ => print!("{:02x} ", byte),
            }
        }
    
        println!("");
        pos += BYTES_PER_LINE;
    }
}
\end{lstlisting}

\verb|while let Ok(_) {...}| -- с помощью этой структуры управление ходом выполнения программы цикл продолжается до тех пор, пока \verb|f.read_exact()| не вернет \verb|Err|, что случится, когда закончатся байты для чтения.

\verb|f.read_exact()| -- метод из типажа \verb|Read|, передающий данные из источника (в данном случае \verb|f|) в буфер, предоставленный в качестве аргумента. Его работа завершиться при заполнении буфера.

Каждый метод итератора \verb|nth()| возвращает \verb|Option|. Когда $ n $ превышает длину итератора, возвращается \verb|None|. Для обработки значений \verb|Option| используются вызовы метода \verb|expect()|.

Метод \verb|expect()| считается более удобной версией метода \verb|unwrap()|. Метод \verb|expect()| получает в качестве аргумента сообщение об ошибке, а метод \verb|unwrap()| просто внезапно впадает в панику.

\subsection{Файловые операции, проводимые в Rust}

Основной тип для работы с файловой системой -- \verb|std::fs::File|. Для создания файла доступны два метода: \verb|open()| и \verb|create()|. Если известно, что файл уже существует, то используется \verb|open()|.

Если нужен более жесткий контроль, то используетвся функция \verb|std::fs::OpenOptions|.

\subsection{Безопасное взаимодействие с файловой системой}

В стандартной библиотеке Rust существуют типобезопасные варианты \verb|str| и \verb|String|: \verb|std::path::Path| и \verb|std::path::PathBuf|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
let hello = PathBuf::from("/tmp/hello.txt");
hello.extension();
\end{lstlisting}

Если разбираться с тонкостями реализации \verb|std::fs::Path| и \verb|std::fs::PathBuf|, то выясниться, что они, соответственно, являются надстройками над \verb|std::ffi::OsStr| и \verb|std::ffi::OsString|. То есть, \verb|Path| и \verb|PathBuf| не гарантируют совместимости с UTF-8.

\subsection{Реализация хранилища <<ключ-значение>> с архитектурой, структурированной по записям и доступом только для добавления}

\emph{Шаблон библиотеки} можно создать так
\begin{lstlisting}[
style = bash,
numbers = none
]
cargo new --lib actionkv
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily Cargo.toml},
style = bash,
numbers = none
]
[package]
name = "actionkv"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
betyorder = "1.2"
crc = "1.7"

[lib]  # в контейнере может быть только одна библиотка
name = "libactionkv" # имя создаваемой библиотеки
path = "src/lib.rs"

[[bin]] # [[...]] -- раздел можно повторять
name = "akv_mem"
path = "src/akv_mem.rs"
\end{lstlisting}

Раздел \verb|[[bin]]|, которых может быть много, определяет \emph{исполняемый файл}, созданный из этого контейнера. Синтаксис двойной скобки необходим, поскольку он четко описывает \verb|bin| как раздел, имеющий один или несколько элементов.

Открытый API-интерфейс actionkv состоит из четырех операций: получения, удаления, вставки и обновления.

\subsubsection{Настройка продукта условной компиляции}

В Rust предоставляются широкие возможности изменнения \emph{продукта компиляции} в зависимости от заданной компилятору \emph{целевой архитектуры}. Как правило, речь идет о \emph{целевой операционной системе}, но можно воспользоваться и возможностями, предоставляемыми целевым процессором. Изменение продукта компиляции в зависимости от заданных условий самого процесса компиляции называют \emph{условной компиляцией}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#[cfg(target_os = "windows")]
const USAGE: &str = "
Usage:
    akv_mem.exe FILE get KEY
    akv_mem.exe FILE delete KEY
    akv_mem.exe FILE insert KEY VALUE
    akv_mem.exe FILE update KEY VALUE
";

#[cfg(not(target_os = "windows"))]
const USAGE: &str = "
Usage:
    ...
";
...
\end{lstlisting}

{\color{blue}
Для добавления в проект условной компиляции нужно аннотировать исходный код атрибутами \verb|cfg|. Атрибут \verb|cfg| работает вместе с целевым параметром, предоставляемым \verb|rustc| в ходе компиляции \cite[\strbook{296}]{mcnamara-rust-in-action:2023}.
}

Для предоставления в коде двух определений \verb|const USAGE| используется условная компиляция. Когда проект создается под Windows, строка использования содержит расширение файла \verb|.exe|. В получаемые на выходе двоичные файлы включаются только те данные, которые имеют отношение к их целевому назначению.

Для отрицания следует использовать выражение \verb|#cfg(not(...))|. Для сопоставления с элементами списка доступны также выражения \verb|#[cfg(all(...))]| и \verb|#[cfg(any(...))]|. Кроме всего этого, атрибуты \verb|cfg| можно настроить при вызове \verb|cargo| или \verb|rustc| с помощью аргумента командной строки \verb|--cfg ATTRIBUTE| \cite[\strbook{297}]{mcnamara-rust-in-action:2023}.

В Rust при проведении операций с файлами может возвращаться ошибки типа \verb|std::io::ErrorKind::UnexpectedEof|. EOF -- это нулевой байт (\verb|0u8|).

При чтении данных из файла операционная система сообщает приложению о количестве байтов, успешно считаных из хранилища. Если успешного считывания байтов с диска не произошло и при этом не возникла никакая ошибочная ситуация, то операционная система, а стало быть, и приложение, предполагают, что достигнут конец файла -- EOF.

Хеш-функция -- отображение значений переменной длины на значения фиксированной длины. На практике значение, возвращаемое хеш-функцией. является целым числом.

Базовая хеш-функция для \verb|&str|, которая просто интерпретирует первый символ строки как целое число без знака. То есть первый символ строки используется этой функцией в качестве хеш-значения
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fn basic_hash(
    key: &str  // любое строковое значение
) -> u32 {
    let first = key.chars()
                    .next()  // -> значение типа Option: Some(char) | None
                    .unwrap_or('\0');
    unsafe {
        std::mem::transmute::<char, u32>(first)
    }
}
\end{lstlisting}

Итератор \verb|.chars()| преобразует строку в серию символьных значений, каждое длиной 4 байта. \verb|.next()| возвращает значение типа \verb|Option| с распаковкой либо в \verb|Some(char)|, либо, для пустых строк, в \verb|None|. 

Функция \verb|unwrap_or()| ведет себя как \verb|unwrap()|, но при встрече с \verb|None| не паникует, а предоставляет значение.

Если несколько входных параметров начинаются с одного и того же символа, на выходе будет одинаковый результат. Такое происходит всякий раз, когда бесконечное пространство входных параметров отображается на конечное пространство, но в данном случае это имеет крайне негативные последствия.

Хеш-таблицы, включая имеющуюся в Rust карту \verb|HashMap|, справляются с этой особенностью, которую называют хеш-коллизией. Для ключей с одинаковым хеш-значением в этих таблицах предоставляется место для резервных копий. Обычно это резервное хранилище относится к типу \verb|Vec<T>|, и называется хранилищем коллизий. При вознинковении коллизий выполняется обращение к хранилищу коллизий и происходит его сквозное сканирование. По мере увеличения хранилища это линейное сканирование занимает все больше и больше времени.

Буквальный синтаксис в стандартной библиотеке Rust для \verb|HashMap| не предоставляется. 
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
use std::collections::HashMap;

fn main() {
    let mut capitals = HashMap::new();  // создаем экземпляр 'словаря' {}
    
    capiatls.insert("Cook Islands", "Avarua");
    capitals.insert("Fiji", "Suva");
    capitals.insert("Kiribati", "South Tarawa");
    capitals.insert("Niue", "Alofi");
    capitals.insert("Tonga", "Nuku'alofa");
    
    let tonga_capital = capitals["Tonga"];
    // Или так
    // let tonga_capital = capitals.get("Tonga").expect("Oops");
    println!("Capital of Tonga is: {}", tongan_capital);
}
\end{lstlisting}

В Python можно было бы сделать так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
capitals: t.Dict[str, str] = {}

capitals.update(**{"Cook Islands", "Avarua"})
capitlas["Fiji"] = "Suva"
...
tonga_capital = captials["Tonga"]
tonga_capital = capitals.get("Tonga", None)
\end{lstlisting}

При поддержке расширенной экосистемы Rust имеется возможность вставки JSON-строк в код Rust
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#[macro_use]  // использование макросов контейнера serde_json
extern crate serde_json;

fn main() {
    let capitals = json!({
        "Cook Islnads": "Avarua",
        "Fiji": "Suva",
    });

    println!("Capital of Tonga is: {}", capitals["Tonga"]);
}
\end{lstlisting}

\verb|capitals["Tonga"]| возвращает ссылку на значение, предназначенную \emph{только для чтения}.

NB: используйте \verb|HashMap|, пока не будет веских оснований для использования \verb|BTreeMap|. Структура \verb|BTreeMap| работает быстрее, если ключи обладают естественной упорядоченностью и ваше приложение пользуется таким их расположением.

\begin{itemize}
	\item \verb|std::collections::HashMap| (с хеш-функцией \verb|SipHash|): вариант, обладающий криптографической безопасностью и устойчивостью к атакам типа <<отказ в обслуживании>>, но работающий медленее других хеш-функций.
	
	\item \verb|std::collections::BTreeMap|: вариант, более подходящий \emph{для ключей с естественной упорядоченностью}, где согласованность кеша может обеспечить ускорение работы.
\end{itemize}

\section{Работа в сети}

\emph{Типажные объекты} являются посредниками конкретных типов. Синтаксис \verb|Box<dyn std::error::Error>| означает \verb|Box| (указатель) на \emph{любой тип} с реализацией \verb|std::error::Error|.

\emph{Типажные объекты} добавляют в Rust форму \emph{полиморфизма}, то есть допускают посредством \emph{динамической диспетчеризации} совместное использование интерфейса сразу несколькими типами. А \emph{обобщения} допускают \emph{полиморфизм} посредоством \emph{статической диспетчеризации}. Выбор между обобщением и типажными объектами обычно основывается на компромиссах между дисковым пространством и временем:
\begin{itemize}
	\item Обобщения используют больше дискового пространства и характеризуются более высоким темпом выполнения программы.
	
	\item Типажные объекты занимают меньше дискового пространства, но из-за косвенности указателя влекут за собой незначительные издержки времени выполнения.
\end{itemize}

Типажные объекты существуют в трех формах:
\begin{itemize}
	\item \verb|&dyn Trait|: заимствуется,
	
	\item \verb|&mut dyn Trait|: заимствуется,
	
	\item \verb|Box<dyn Trait>|: находится в чьем-то владении.
\end{itemize}

\begin{lstlisting}[
title = {\sffamily Использование типажного объекта \texttt{\&dyn Enchanter}},
style = c_cpp,
numbers = none
]
use rand;
use rand::seq::SliceRandom;
use rand::Rng;

#[derive(Debug)]
struct Dwarf {};

#[derive(Debug)]
struct Elf {};

#[derive(Debug)]
struct Human {};

#[derive(Debug)]
enum Thing {
    Sword,
    Trinket,
}

trait Enchanter: std::fmt::Debug {
	// self -- это структура, к которой будет подмешан этот типаж
    fn competency(&self) -> f64; // абстрактный метод
    
    fn enchant(&self, thing: &mut Thing) {
        let probability_of_success = self.competency();
        let spell_is_successful = rand::thread_rng().gen_bool(probability_of_success);
        
        print!("{:?} mutters incoherently. ", self); // self можно вывести на печать благодаря std::fmt::Debug
        if spell_is_successful {
            println!("The {:?} glows brightly.", thing);
        } else {
            println!("The {:?} fizzes, \
                then turns into a worthless trinket.", thing);
        }
    }
}

// реализация методов для структуры Dwarf по протоколу Enchanter
impl Enchanter for Dwarf {
    fn competency(&self) -> f64 {
        0.5
    }
}

// реализация методов для структуры Elf по протоколу Enchanter
impl Enchanter for Elf {
    fn competency(&self) -> f64 {
         0.95
    }
}

// реализация методов для структуры Human по протоколу Enchanter
impl Enchanter for Human {
    fn competency(&self) -> f64 {
        0.8
    }
}

fn main() {
    let mut it = Thing::Sword;
    
    let d = Dwarf {};
    let e = Elf {};
    let h = Human {};
    
    let party: Vec<&dyn Enchanter> = vec![&d, &e, &h];  // тиажный объект
    // метод choose() берется из типажа rand::seq::SliceRandom
    let spellcaster = party.choose(&mut rand::thread_rng()).unwrap();
    
    spellcaster.enchant(&mut it);
}
\end{lstlisting}

\verb|&dyn Rng| -- это ссылка на что-то, имеющее реализацию типажа \verb|Rng|, \verb|&ThreadRng| -- ссылка на значение \verb|ThreadRng|.

Приведем несколько типичных случаев использования типажных объектов:
\begin{itemize}
	\item Создание коллекции гетерогенных объектов,
	
	\item Возвращение значения. Типажные объекты позволяют функциям возвращать несколько конкретных типов/
	
	\item Поддержка динамической диспетчеризации, при этом вызываемая функция определяется в ходе выполнения программы, а не в ходе компиляции ее кода.
\end{itemize}

{\color{blue}
\emph{Типажные объекты} ближе к \emph{миксинам}. Типажные объекты не существуют самы по себе, они -- агенты какого-то другого типа.
}

Номера портов -- это чисто виртуальные понятия. Это просто значения типа \verb|u16|. Номера портов позволяют по одному и тому же IP-адресу размещать сразу несколько служб.

Утилита командной строки, предназначенная для разрешения IP-адресов из имен хостов
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use std::net::{SocketAddr, UdpSocket};
use std::time::Duration;

use clap::{App, Arg};
use rand;
use trust_dns::op::{Message, MessageType, OpCode, Query};
use trust_dns::rr::domain::Name;
use trust_dns::rr::record_type::RecordType;
use trust_dns::serialize::binary::*;

fn main() {
    let app = App::new("resolve")
        .about("A simple to use DNS resolver")
        .arg(Arg::with_name("dns-server").short("s").default_value("1.1.1.1"))
        .arg(Arg::with_name("domain-name").required(true))
        .get_matches();
        
    let domain_name_raw = app
        .value_of("domain-name").unwrap();
    let domain_name = Name::from_ascii(&domain_name_raw).unwrap();
    
    let dns_server_raw = app.value_of("dns-server").unwrap();
    let dsn_server: SockerAddr = format!("{}:53", dns_server_raw)
        .parse()
        .expect("invalid address");
        
    let mut request_as_bytes: Vec<u8> = Vec::with_capacity(512);
    let mut response_as_bytes: Vec<u8> = vec![0; 512];
    
    let mut msg = Message::new();
    msg
        .set_id(rand::random::<u16>())
        .set_message_type(MessageType::Query)
        .add_query(Query::query(domain_name, RecordType::A))
        .set_op_code(OpCode::Query)
        .set_recursion_desired(true);
        
    let mut encoder = 
        BinEncoder::new(&mut request_as_bytes);
        msg.emit(&mut encoder).unwrap();
        
    let localhost = UdpSocket::bind("0.0.0.0:0")
        .expect("cannot bind to local socket");
    let timeout = Duration::from_secs(3);
    localhost.set_read_timeout(Some(timeout)).unwrap();
    localhost.set_nonblocking(false).unwrap();
    
    let _amt = localhost
        .send_to(&request_as_bytes, dns_server)
        .expect("socket misconfigured");
        
    let (_amt, _remote) = localhost
        .recv_from(&mut response_as_bytes)
        .expect("timeout reached");
        
    let dns_message = Message::from_vec(&response_as_bytes)
        .expect("unable to parse response");
        
    for answer in dns_message.answers() {
         if answer.record_type() == RecordType::A {
              let resource = answer.rdata();
              let ip = resource
                  .to_ip_addr()
                  .expect("invalid IP address received");
              println!("{}", ip.to_string());
         }
    }
}
\end{lstlisting}

\verb|"0.0.0.0:0"| -- прослушивание всех адресов на произвольном порту. Конкретный порт выбирается операционной системой.

\verb|Vec::with_capacity(512)| создает \verb|Vec<T>| {\color{red}с длиной 0} и емкостью 512, \verb|vec![0; 512]| создает \verb|Vec<T>| с длиной 512 и емкостью 512.

\subsection{Способы обработки ошибок, наиболее удобные для помещения в библиотеки}

Возвращение \verb|Result<T, E>| успешно работает только при наличии одного типа ошибок \verb|E|. Но, как только возникает потребность возвращения нескольких типов ошибок, ситуация резко усложняется.

{
При работе с отдельными файлами код лучше компилировать с помощью команды \verb|rustc <file_name>|, отказавшись от использования \verb|cargo build|. Например, если файл называется \verb|io-error.rs|, то в командной строке оболочки следует набрать \verb|rustc io-error.rs && ./io-error[.exe]|.
}

Оператор \verb|?| это удобная синтаксическая замена макросу \verb|try!|, выполняющему две функции:
\begin{itemize}
	\item При обнаружении \verb|Ok(value)| это выражение вычисляется в значение \verb|value|,
	
	\item при обнаружении \verb|Err(err)|, \verb|try!| или \verb|?| выполняет возвращение сразу же после попытки преобразования \verb|err| в тип \verb|error|, определение которого находится в вызывающей функции.
\end{itemize}

В Rust-подобном псевдокоде макрос \verb|try!| можно определить следующим образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
macro try {
    match expression {
        Result::Ok(val) => val,
        Result::Err(err) => {
           let converted = convert::From::from(err);
           return Result::Err(converted);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily Использование типажного объекта в возвращаемом значении},
style = c_cpp,
numbers = none
]
use std::fs::File;
use std::error::Error;
use std::net::Ipv6Addr;

// типажный объект "обобщает" типы Error и AddrParseError
fn main() -> Result<(), Box<dyn Error>> {
    let _f = File::open("invisible.txt")?; // тип ошибки std::io::Error
    
    let _localhost = "::1"
        .parse::<Ipv6Addr>()? // тип ошибки std::net::AddrParseError
        
    Ok(())
}
\end{lstlisting}

{\color{blue}
\emph{Типажный объект}, \verb|Box<dyn Error>|, является представителем \emph{любого типа}, реализующего тип \verb|Error|.
}

{\color{red}Необходимость заключения \emph{типажных объектов} в \verb|Box| обуславливается тем, что их \emph{размер} (в байтах в стеке) \emph{на момент компиляции не известен}.} У \verb|Box| есть известный размер в стеке. {\color{blue}И смысл его применения заключается в том, чтобы \emph{указывать} на то, для чего этот \emph{размер неизвестен}, в том числе и на типажные объекты.}

Использование типажных объектов известно также как затирание типов. При этом Rust теряет сведения о том, что ошибка берет свое начало в вышестоящих контейнерах.

Использование \verb|Box<dyn Error>| в качестве варианта ошибки, закладываемого в \verb|Result|, означает, что \emph{вышестоящие типы ошибок} в некотором смысле \emph{теряются}. {\color{blue}Исходные ошибки теперь перобразуются в один и тот же тип.}

Функция \verb|map_err()| отображает ошибку на функцию. В качестве функции могут использоваться варианты перечисления. Оператор \verb|?| ставится в самом конце. Иначе функция может возвратить управление еще до того, как у кода будет возможность преобразовать ошибку.

\begin{lstlisting}[
title = {\sffamily Заключение вышестоящих ошибок в оболочку нашего собственного типа},
numbers = none
]
use std::io;
use std::fmt;
use std::net;
use std::fs::File;
use std::net::Ipv6Addr;

#[derive(Debug)]
enum UpstreamError {
    IO(io::Error),
    Parsing(net::AddrParseError),
}

// реализация метода fmt для перечисления UpstreamError
// в соответствии с типажом Display
impl fmt::Display for UpstreamError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

// реализация всех нужных для работы методов
// в соответствии с типажом Error
impl error::Error for UpstreamError { }

fn main() -> Result<(), UpstreamError> {
    let _f = File::open("invisible.txt")
        .map_err(UpstreamError::IO)?;
        
    let _localhost = "::1"
        .parse::<Ipv6Addr>()
        .map_err(UpstreamError::Parsing)?;
        
    Ok(())
}
\end{lstlisting}

Можно также избавиться от вызова \verb|map_err()|. Но для этого нужна реализация типажа \verb|From|. Типаж \verb|std::convert::From| располагает единственным необходимым метдом \verb|from()|. Чтобы придать нашим двум вышестоящим типам ошибок возможность подвергаться преобразованиям, нужны два блока \verb|impl|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
impl From<io::Error> for UpstreamError {
    fn from(error: io::Error) -> Self {
         UpstreamError::IO(error) // io::Error -> UpstreamError
    }
} 

impl From<net::AddrParseError> for UpstreamError {
    fn from(error: net::AddrParseError) -> Self {
        UpstreamError::Parsing(error) // net::AddrParseError -> UpstreamError
    }
}
\end{lstlisting}

Теперь функция \verb|main()| возвращается в присущую ей простую форму
\begin{lstlisting}[
style = c_cpp,
numbers = none,
]
fn main() -> Result<(), UpstreamError> {
    let _f = File::open("invisible.txt")?;
    let _localhost = "::1".parse::<Ipv6Addr>()?;
    
    Ok(())
}
\end{lstlisting}

\section{Время и хронометраж}

Структуры без полей \verb|struct Clock;| называют \emph{типами с нулвым размером} (zero-sized type) или ZST.

\subsection{Предоставление полноценного интерфейса командной строки}

Конфигурация проекта
\begin{lstlisting}[
style = bash,
numbers = none
]
[package]
name = "clock"
version = "0.1.1"
authors = ["Tim ..."]
edition = "2018"

[dependencies]
chrono = "0.4"
clap = "2"
\end{lstlisting}

Приложение
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
use chrono::DateTime;
use chrono::Local;
use clap::{App, Arg};

struct Clock;

impl Clock {
    fn get() -> DateTime<Local> {
        Local::now()
    }

    fn set() -> ! {
        unimplemented!()
    }
}

fn main() {
   let app = App::new("clock")
       .version("0.1")
       .about("Gets and ...")
       .arg(
           Arg::with_name("action")
               .takes_value(true)
               .possible_values(&["get", "set"])
               .default_value("get"),
       )
       .arg(
           Arg::with_name("std")
               .short("s")
               .long("use-standard")
               .takes_value(true)
               .possible_values(&[
                   "rfc2822",
                   "rfc3339",
                   "timestamp",
               ])
               .default_value("rfc3339"),
       )
       .arg(Arg::with_name("datetime").help(
           "When <action> is 'set' ..."
       ));
       
   let args = app.get_matches();
   
   let action = args.value_of("action").unwrap();
   let std = args.value_of("std").unwrap();
   
   if action == "set" {
       unimplemented!()
   }

    let now = Clock::get();
    match std {
        "timestamp" => println!("{}", now.timestamp()),
        "rfc28222" => println!("{}", now.to_rfc2822()),
        "rfc3339" => println!("{}", now.to_rfc3339()),
        _ => unreachable!(),
    }
}
\end{lstlisting}

\subsection{tСоглашения о наименовании типов, действующие в libc}

В libc при обозначении типов предпочтение отдается именам в символах нижнего регистра, а стиль PascalCase не используется. То есть, там, где в Rust использовалось бы название \verb|TimeVal|, в libc ему соответствовало бы имя \verb|timeval|. При работе с псевдонимами типов соглашение немного меняется. К имнам псевдонимов типов в libc добавляется знак нижнего подчеркивания, за которым следует буква \verb|t| (то есть \verb|_t|)
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
libc::{timeval, time_t, suseconds_t};
\end{lstlisting}

В Rust-синтаксисе они определяются следующим образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#![allow(non_camel_case_types)] // разрешает давать имена типам не в camel-case

type time_t = i64;  // псевдоним типа
type suseconds_t = i64; // псевдоним типа

pub struct timeval {
    pub tv_sec: time_t, // секунды с начала эпохи
    pub tv_usec: suseconds_t, // дробная составляющая текущей секунды
}
\end{lstlisting}

Чтобы поместить в контейнер привязку к libc, необходимую для платформ, отличных от Windows
\begin{lstlisting}[
title = {\sffamily Cargo.toml},
style = c_cpp,
numbers = none
]
...
[target.'cfg(not(windows))'.dependencies]
libc = "0.2"
\end{lstlisting}

\subsection{Листинг полного кода clock v0.1.2}

Конфигурация проекта
\begin{lstlisting}[
title = {\sffamily Cargo.toml},
style = c_cpp,
numbers = none
]
[package]
name = "clock"
version = "0.1.2"
authors = ["Tim ..."]
edition = "2018"

[dependencies]
chrono = "0.4"
clap = "2"

[target.'cfg(windows)'.dependencies]
winapi = "0.2"
kernel32-sys = "0.2"

[target.'cfg(not(windows))'.dependencies]
libc = "0.2"
\end{lstlisting}

Кроссплатформенный код установки системного времени
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
#[cfg(windows)]
use kernel32;
#[cfg(not(windows))]
use libc;
#[cfg(windows)]
use winapi;

use chrono::{DateTime, Local, TimeZone};
use clap::{App, Arg};
use std::mem::zeroed;

struct Clock;

impl Clock {
    fn get() -> DateTime<Local> {
        Local::now()
    }

    #[cfg(windows)]
    fn set<Tz: TimeZone>(t: DateTime<Tz>) -> () {
        use chrono::Weekday;
        use kernel32::SetSystemTime;
        use winapi::{SYSTEMTIME, WORD};
        
        let t = t.with_timezone(&Local);
        
        let mut systime: SYSTEMTIME = unsafe { zeroed() };
        
        let dow = match t.weekday() {
            Weekday::Mon => 1,
            Weekday::Tue => 2,
            Weekday::Wed => 3,
            Weekday::Thu => 4,
            Weekday::Fri => 5,
            Weekday::Sat => 6,
            Weekday::Sun => 0,
        };
    
        let mut ns = t.nanosecond();
        let is_leap_second = ns > 1_000_000_000;
        
        if is_leap_second {
            ns -= 1_000_000_000;
        }
    
        systime.wYear = t.year() as WORD;
        systime.wMonth = t.month() as WORD;
        systime.wDayOfWeek = dow as WORD;
        systime.wDay = t.day() as WORD;
        systime.wHour = t.hour() as WORD;
        systime.wMinute = t.minute() as WORD;
        systime.wSecond = t.second() as WORD;
        systime.wMilliseconds = (ns / 1_000_000) as WORD;
        
        let systime_ptr = &systime as *const SYSTEMTIME;
        
        unsafe {
             SetSystemTime(systime_ptr);
        }
    }

    #[cfg(not(windows))]
    fn set<Tz: TimeZone>(t: DateTime<Tz>) -> () {
        use libc::{timeval, time_t, susecond_t};
        use libc::{settimeofday, timezone};
        
        let t = t.with_timezone(&Local);
        let mut u: timeval = unsafe { zeroed() };
        
        u.tv_sec = t.timestamp() as time_t;
        u.tv_usec = t.timestamp_subsec_micros() as suseconds_t;
        
        unsafe {
            let mock_tz: *const timezone = std::ptr::mull();
            settimeofday(&u as *const timeval, mock_tz);
        }
    }
}

fn main() {
    let app = App::new("clock")
        .version("0.1.2")
        .about("Gets ...")
        .after_help(
            "Note: UNIX timestamps are parsed \
            seconds ..."
        )
        .arg(
            Arg::with_name("action")
                .takes_value(true)
                .possible_values(&["get", "set"])
                .default_value("get"),
        )
        .arg(
            Arg::with_name("std")
                .short("s")
                .long("use-standard")
                .takes_value(true)
                .possible_values(&[
                    "rfc2822",
                    "rfc3339",
                    "timestamp",
                ])
                .default_value("rfc3339"),
        )
        .arg(
            Arg::with_name("datetime").help(
            "When ..."
            ));
        
        let args = app.get_matches();
        
        let action = args.value_of("action").unwrap();
        let std = args.value_of("std").unwrap();
        
        if action == "set" {
            let t_ = args.value_of("datetime").unwrap();
            
            let parser = match std {
                "rfc2822" => DateTime::parse_from_rfc2822,
                "rfc3339" => DateTime::parse_from_rfc3339,
                _ => unimplemented!(),
            };
        
        let err_msg = format!(
            "Unable to parse {} according to {}",
            t_, std
        );
        let t = parser(t_).expect(&err_msg);
        
        Clock::set(t)
    }
    
    let now = Clock::get();
    
    match std {
        "timestamp" => println!("{}", now.timestamp()),
        "rfc2822" => println!("{}", now.to_rfc2822()),
        "rfc3339" => println!("{}", now.to_rfc3339()),
        _ => unreachable!(),
    }
    
}
\end{lstlisting}









% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{koltzov-c-lang:2019}{ \emph{Кольцов Д.М.} Си на примерах. Практика, практика и только практика. -- СПб.: Наука и Техника, 2019. -- 288 с.}
	
	\bibitem{mcnamara-rust-in-action:2023}{\emph{Макнамара Т.} Rust в действии. -- СПб.: БХВ-Петербург, 2023. -- 528 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
